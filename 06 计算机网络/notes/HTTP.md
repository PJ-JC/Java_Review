# 面试题

## 1.Https是有状态还是无状态

http协议无状态中的【状态】到底指的是什么？！

先来看这句话的另外两个概念：（标准的http协议是无状态的，无连接的）

无状态指的是协议对于事物处理没有记忆能力。**缺少状态意味着如果后续处理需要前面的信息，就必须要重传。**

1. 标准的http协议指的是不包括cookies, session，application的http协议，他们都不属于标准协议，虽然各种网络应用提供商，实现语言、web容器等，都默认支持它

1. 无连接指的是什么
	1. 每一个访问都是无连接，服务器挨个处理访问队列里的访问，处理完一个就关闭连接，这事儿就完了，然后处理下一个新的
	1. 无连接的含义是限制**每次连接只处理一个请求**。服务器处理完客户的请求，并收到客户的应答后，即断开连接
	

HTTP,UDP都是无状态协议

TCP,FTP是有状态协议

## 2. HTTP 1.0，1.1，2.0每个版本做的更新（阿里）

## 3. 怎么解决HTTP无状态 (美团） ##

- 通过Cookie保存状态信息
- 通过Session保存状态信息
- 重写URL
- 隐藏表单域

## 4. Http 有哪些方法 （京东）

HTTP1.0 定义了三种请求方法： GET, POST 和 HEAD方法。

HTTP1.1 新增了五种请求方法：OPTIONS、PUT、PATCH、DELETE、TRACE 和 CONNECT 方法。

| 序号 | 方法    | 描述                                                         |
| :--- | :------ | :----------------------------------------------------------- |
| 1    | GET     | 请求指定的页面信息，并返回实体主体。                         |
| 2    | HEAD    | 类似于 GET 请求，只不过返回的响应中没有具体的内容，用于获取报头 |
| 3    | POST    | 向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST 请求可能会导致新的资源的建立和/或已有资源的修改。 |
| 4    | PUT     | 从客户端向服务器传送的数据取代指定的文档的内容。             |
| 5    | DELETE  | 请求服务器删除指定的页面。                                   |
| 6    | CONNECT | HTTP/1.1 协议中预留给能够将连接改为管道方式的代理服务器。    |
| 7    | OPTIONS | 允许客户端查看服务器的性能。                                 |
| 8    | TRACE   | 回显服务器收到的请求，主要用于测试或诊断。                   |
| 9    | PATCH   | 是对 PUT 方法的补充，用来对已知资源进行局部更新 。           |

## 5. HTTP和HTTPS的区别（贝贝）

其实HTTP+加密+认证+完整性保护 = HTTPS，在HTTP层和TCP之间加了一个SSL/TLS层，HTTP协议采用**明文传输信息，存在信息窃听、信息篡改和信息劫持的风险**，而协议TLS/SSL具有**身份验证、信息加密和完整性校验**的功能，可以避免此类问题发生。

![](https://raw.githubusercontent.com/wuqifan1098/picBed/master/HTTP-HTTPS.png)

#### HTTP缺点

- 通信使用明文，可能被窃听

- 不验证通信方的身份，可能遭遇伪装

- 无法证明报文的完整性，有可能遭遇篡改

https://juejin.im/post/5af557a3f265da0b9265a498

HTTP 是明文传输，HTTPS 通过 SSL\TLS 进行了加密

HTTP 的端口号是 80，HTTPS 是 443

HTTPS 需要到 CA 申请证书，一般免费证书很少，需要交费

HTTPS 的连接很简单，是无状态的；HTTPS 协议是由 SSL+HTTP 协议构建的可进行加密传输、身份认证的网络协议，比 HTTP 协议安全。

作者：sunshine小小倩链接：https://juejin.im/post/59e4c02151882578d02f4aca

https://juejin.im/post/5caab0bff265da24cf311d5b

# HTTP原理

HTTP：当用户在浏览器的地址栏中输入所要访问Web的URL以后，HTTP的处理过程即会开始，HTTP中默认的端口是**80端口**，它的工作机制，首先是客户端向服务器的80端口建立一个TCP连接，然后再这个连接上进行请求和应答以及数据报文的发送。具体过程成如下：

1、**客户端连接到Web服务器**
一个HTTP客户端，通常是浏览器，与Web服务器的HTTP端口（默认为80）建立一个TCP套接字连接。例如，http://www.oakcms.cn。

2、**发送HTTP请求**
通过TCP套接字，客户端向Web服务器发送一个文本的请求报文，一个请求报文由请求行、请求头部、空行和请求数据4部分组成。

3、**服务器接受请求并返回HTTP响应**
Web服务器解析请求，定位请求资源。服务器将资源复本写到TCP套接字，由客户端读取。一个响应由状态行、响应头部、空行和响应数据4部分组成。

4、**释放连接TCP连接**
若connection 模式为close，则服务器主动关闭TCP连接，客户端被动关闭连接，释放TCP连接;若connection 模式为keepalive，则该连接会保持一段时间，在该时间内可以继续接收请求;

5、**客户端浏览器解析HTML内容**
客户端浏览器首先解析状态行，查看表明请求是否成功的状态代码。然后解析每一个响应头，响应头告知以下为若干字节的HTML文档和文档的字符集。客户端浏览器读取响应数据HTML，根据HTML的语法对其进行格式化，并在浏览器窗口中显示。

例如：在浏览器地址栏键入URL，按下回车之后会经历以下流程：

1、浏览器向 DNS 服务器请求**解析该 URL 中的域名所对应的 IP 地址**;

2、解析出 IP 地址后，根**据该 IP 地址和默认端口 80，和服务器建立TCP连接**;

3、浏览器**发出读取文件(URL 中域名后面部分对应的文件)的HTTP 请求**，该请求报文作为 TCP 三次握手的第三个报文的数据发送给服务器;

4、服务器**对浏览器请求作出响应，并把对应的 html 文本发送给浏览器**;

5、**释放 TCP连接**;

6、浏览器将**该 html 文本并显示内容**; 

# HTTP请求

 HTTP请求是客户端往服务端发送请求动作，告知服务器自己的要求。

 HTTP请求由**状态行、请求头、请求正文**三部分组成：

状态行：包括请求方式Method、资源路径URL、协议版本Version；

请求头：包括一些访问的域名、用户代理、Cookie等信息；

请求正文：就是HTTP请求的数据。

请求方式Method一般有**GET、POST、PUT、DELETE，含义分别是获取、修改、上传、删除**

# HTTP响应

## 响应数据格式

HTTP响应由三部分组成：状态行、响应头、响应正文；

状态行：包括协议版本Version、状态码Status Code、回应短语；

响应头：包括搭建服务器的软件，发送响应的时间，回应数据的格式等信息；

响应正文：就是响应的具体数据。

|-----|---------------------|
| 1xx | 表示HTTP请求已经接受，继续处理请求 |
| 2xx | 表示HTTP请求已经处理完成      |
| 3xx | 表示把请求访问的URL重定向到其他目录 |
| 4xx | 表示客户端出现错误           |
| 5xx | 表示服务端出现错误           |

## 常见状态码

		200---OK/请求已经正常处理完毕
	
	    301---/请求永久重定向
	
	    302---/请求临时重定向
	
	    304---/请求被重定向到客户端本地缓存
	
	    400---/客户端请求存在语法错误
	
	    401---/客户端请求没有经过授权
	
	    403---/客户端的请求被服务器拒绝，一般为客户端没有访问权限
	
	    404---/客户端请求的URL在服务端不存在
	
	    500---/服务端永久错误
	
	    503---/服务端发生临时错误

# HTTP报文格式

HTTP报文是HTTP应用程序之间传输的数据块，HTTP报文分为HTTP请求报文和HTTP响应报文，但是无论哪种报文，他的整体格式是类似的，大致都是由**起始、首部、主体**三部分组成，起始说明报文的动作，首部说明报文的属性，主体则是报文的数据。

## 请求报文

请求报文的起始由请求行构成（有些资料称为状态行，名字不一样而已，都是指的一个东西），用来说明该请求想要做什么，由**<Method>、<URL>、<Version>** 三个字段组成，注意每个字段之间都有一个空格。

 其中<Method>字段有不同的值：

                GET   --- 访问服务器的资源
    
                POST  --- 向服务器发送要修改的数据
    
                HEAD  --- 获取服务器文档的首部
    
                PUT   --- 向服务器上传资源
    
                DELETE--- 删除服务器的资源

<URL>字段表示服务器的资源目录定位

<Version>字段表示使用的http协议版本

![](https://raw.githubusercontent.com/wuqifan1098/picBed/master/%E8%AF%B7%E6%B1%82%E6%8A%A5%E6%96%87.png)

## 响应报文

响应报文的起始由状态行构成，用来说明服务器做了什么，由<Version>、<Status-Code>、<Phrase>三个字段组成，同样的每个字段之间留有空格；

![](https://raw.githubusercontent.com/wuqifan1098/picBed/master/%E5%93%8D%E5%BA%94%E6%8A%A5%E6%96%87.png)


# HTTP协议更替

HTTP/0.9

HTTP协议的最初版本，功能简陋，**仅支持请求方式GET，并且仅能请求访问HTML格式的资源**。

HTTP/1.0    

在0.9版本上做了进步，**增加了请求方式POST和HEAD**；不再局限于0.9版本的HTML格式，根据Content-Type可以**支持多种数据格式**，即MIME多用途互联网邮件扩展，例如text/html、image/jpeg等；同时也开始支持cache，就是当客户端在规定时间内访问统一网站，直接访问cache即可。

但是1.0版本的工作方式是**每次TCP连接只能发送一个请求**，当服务器响应后就会关闭这次连接，**下一个请求需要再次建立TCP连接，就是不支持keepalive**。

HTTP/1.1    

解决了1.0版本的keepalive问题，**1.1版本加入了持久连接，一个TCP连接可以允许多个HTTP请求**； 加入了管道机制，一个TCP连接同时允许多个请求同时发送，增加了并发性；新增了请求方式**PUT、PATCH、DELETE**等。

HTTP/2.0

为了解决1.1版本利用率不高的问题，提出了HTTP/2.0版本。增加双工模式，即**不仅客户端能够同时发送多个请求，服务端也能同时处理多个请求**，解决了队头堵塞的问题；HTTP请求和响应中，状态行和请求/响应头都是些信息字段，并没有真正的数据，因此在2.0版本中将所有的信息字段建立一张表，为表中的每个字段建立索引，客户端和服务端共同使用这个表，他们之间就以索引号来表示信息字段，这样就避免了1.0旧版本的重复繁琐的字段，并以压缩的方式传输，提高利用率。

另外也增加服务器推送的功能，即不经请求服务端主动向客户端发送数据。

当前主流的协议版本还是HTTP/1.1版本。

## 1.0和1.1区别

在**HTTP/1.0中默认使用短连接**。也就是说，**客户端和服务器每进行一次HTTP操作，就建立一次连接**，任务结束就中
断连接。当客户端浏览器访问的某个HTML或其他类型的Web页中包含有其他的Web资源（如JavaScript文件、图像
文件、CSS文件等），每遇到这样一个Web资源，浏览器就会重新建立一个HTTP会话。

而从**HTTP/1.1起，默认使用长连接**，用以保持连接特性。

# HTTP+加密+认证+完整性保护 = HTTPS

HTTPS其实是有两部分组成：**HTTP + SSL / TLS，也就是在HTTP上又加了一层处理加密信息的模块。**服务端和客户端的信息传输都会通过TLS进行加密，所以传输的数据都是加密后的数据。服务器在给客户端发送的数据是加密的，只有服务器和客户端才能读懂，而且在进行数据交互的时，还需要用对称秘钥（下面有概念）进行验证，但是服务器又是如何将对称秘钥发送给客户端？（下面将会讲到）

## HTTP缺点

- 通信使用明文（不加密），内容可能会被窃听
- 不验证对方的身份，可能遭遇伪装
- 无法证明报文的完整性，又可能已被篡改

## HTTP和HTTPS的区别

（1）HTTPS 协议需要到CA(电子商务认证机构)申请证书，一般免费证书很少，需要交费。

（2）HTTP 是超文本传输协议，信息是**明文传输**，HTTPS 则是**具有安全性的ssl加密传输协议**

（3）HTTP 和 HTTPS 使用的是完全不同的连接方式用的**端口也不一样,前者是80,后者是443**。

（4）HTTP 的连接很简单,**是无状态的**

（5）HTTPS 协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议**要比 HTTP 协议安全**

（6）HTTPS 内容传输经过**完整性校验**

（7）HTTPS 内容经过对称加密，每个连接生成一个唯一的加密密钥

（8）HTTPS 第三方无法伪造服务端（客户端）身份 

## HTTPS加密算法

HTTPS一般使用的加密与HASH算法如下：

- 非对称加密算法：RSA，DSA/DSS
- 对称加密算法：AES，RC4，3DES
- HASH算法：MD5，SHA1，SHA256

对称秘钥:对称密钥加密又叫专用密钥加密，即发**送和接收数据的双方必使用相同的密钥对明文进行加密和解密运算**。通常有两种模式：流加密和分组加密。

非对称秘钥：非对称加密算法需要两个密钥：公开秘钥（publickey）和私有密钥（privatekey）。公开密钥与私有密钥是一对，**如果用公开密钥对数据进行加密，只有用对应的私有密钥才能解密；如果用私有密钥对数据进行加密，那么只有用对应的公开密钥才能解密。因为加密和解密使用的是两个不同的密钥，所以这种算法叫作非对称加密算法。**

## HTTPS加密过程

1. 认证服务器。浏览器内置一个受信任的CA机构列表，并保存了这些CA机构的证书。第一阶段服务器会提供经CA机构认证颁发的服务器证书，如果认证该服务器证书的CA机构，存在于浏览器的受信任CA机构列表中，并且服务器证书中的信息与当前正在访问的网站（域名等）一致，那么浏览器就认为服务端是可信的，并从服务器证书中取得服务器公钥，用于后续流程。否则，浏览器将提示用户，根据用户的选择，决定是否继续。当然，我们可以管理这个受信任CA机构列表，添加我们想要信任的CA机构，或者移除我们不信任的CA机构。

1. 协商会话密钥。客户端在认证完服务器，获得服务器的公钥之后，利用该公钥与服务器进行加密通信，协商出两个会话密钥，分别是用于加密客户端往服务端发送数据的客户端会话密钥，用于加密服务端往客户端发送数据的服务端会话密钥。在已有服务器公钥，可以加密通讯的前提下，还要协商两个对称密钥的原因，是因为非对称加密相对复杂度更高，在数据传输过程中，使用对称加密，可以节省计算资源。另外，会话密钥是随机生成，每次协商都会有不一样的结果，所以安全性也比较高。

1. 加密通讯。此时客户端服务器双方都有了本次通讯的会话密钥，之后传输的所有Http数据，都通过会话密钥加密。这样网路上的其它用户，将很难窃取和篡改客户端和服务端之间传输的数据，从而保证了数据的私密性和完整性。

## TLS/SSL工作原理

HTTPS协议的主要功能基本都依赖于TLS/SSL协议，TLS/SSL的功能实现主要依赖于三类基本算法：散列函数 Hash、对称加密和非对称加密，其利用非对称加密实现身份认证和密钥协商，对称加密算法采用协商的密钥对数据加密，基于散列函数验证信息的完整性。

![](https://raw.githubusercontent.com/wuqifan1098/picBed/master/TSL%20SSL.png)

![](https://raw.githubusercontent.com/wuqifan1098/picBed/master/HTTPS%20C%20S.png)

### 散列函数Hash

常见的有 MD5、SHA1、SHA256，该类函数特点是函数单向不可逆、对输入非常敏感、输出长度固定，针对数据的任何修改都会改变散列函数的结果，用于防止信息篡改并验证数据的完整性; 在信息传输过程中，散列函数不能单独实现信息防篡改，因为明文传输，中间人可以修改信息之后重新计算信息摘要，因此需要对传输的信息以及信息摘要进行加密;

### 对称加密

常见的有AES-CBC、DES、3DES、AES-GCM等，相同的密钥可以用于信息的加密和解密，掌握密钥才能获取信息，能够防止信息窃听，通信方式是1对1; 对称加密的优势是信息传输1对1，需要共享相同的密码，密码的安全是保证信息安全的基础，服务器和 N 个客户端通信，需要维持 N 个密码记录，且缺少修改密码的机制;

### 非对称加密

即常见的 RSA 算法，还包括 ECC、DH 等算法，算法特点是，密钥成对出现，一般称为公钥(公开)和私钥(保密)，公钥加密的信息只能私钥解开，私钥加密的信息只能公钥解开。因此掌握公钥的不同客户端之间不能互相解密信息，只能和掌握私钥的服务器进行加密通信，服务器可以实现1对多的通信，客户端也可以用来验证掌握私钥的服务器身份。 非对称加密的特点是信息传输1对多，服务器只需要维持一个私钥就能够和多个客户端进行加密通信，但服务器发出的信息能够被所有的客户端解密，且该算法的计算复杂，加密速度慢。

**结合三类算法的特点，TLS的基本工作方式是，客户端使用非对称加密与服务器进行通信，实现身份验证并协商对称加密使用的密钥， 然后对称加密算法采用协商密钥对信息以及信息摘要进行加密通信，不同的节点之间采用的对称密钥不同，从而可以保证信息只能通信双方获取。**


作者：jackyshan_链接：https://juejin.im/post/5af557a3f265da0b9265a498来源：掘金著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。