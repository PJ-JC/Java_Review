# 面试题

## 1.tcp如何保证可靠性？（阿里）如果想用udp又想保证可靠性该如何？

-  ACK 机制

在每收到一个**正确的、符合次序的**片段之后，就向发送方(也就是连接的另一段)发送一个特殊的 TCP 片段，用来知会(**ACK，acknowledge**)发送方：我已经收到那个片段了。这个特殊的 TCP片段 叫做 **ACK 回复**。如果一个片段序号为 L，对应ACK 回复有回复号 L+1，也就是接收方期待接收的下一个发送片段的序号。

![](https://raw.githubusercontent.com/wuqifan1098/picBed/master/20190731144133.png)

- 重传机制

如果发送方在一定时间等待之后，还是没有收到 ACK 回复，那么它推断之前发送的片段一定发生了异常。发送方会**重复发送(retransmit)**那个出现异常的片段，等待 ACK 回复，如果还没有收到，那么再重复发送原片段… 直到收到该片段对应的 ACK 回复(回复号为 L+1 的 ACK)。

![](https://raw.githubusercontent.com/wuqifan1098/picBed/master/20190731144207.png)

- 滑动窗口

虽然采用 “ACK 回复” + “重新发送机制” 方式能实现不丢包，但是会存在两个问题。

**1.效率低的问题。**
发送方保持发送 -> 等待ACK -> 发送 -> 等待ACK…的单线工作方式，这样的工作方式叫做 **stop-and-wait**。stop-and-wait 虽然实现了 TCP 通信的可靠性，但同时牺牲了网络通信的效率。同时，在等待ACK的时间段内，我们的网络都处于闲置(idle)状态

**2.有点小缺陷**
如果片段一直没有被确认，会**导致后续的片段无法发送出去**。

滑动窗口被同时应用于接收方和发送方, 发送方和接收方各有一个滑窗。当片段位于滑窗中时，表示 TCP 正在处理该片段。此外，如果滑窗中可以有多个片段，也就是可以同时处理多个片段。

https://www.itcodemonkey.com/article/6617.html

由于在传输层UDP已经是不可靠的连接，那就要**在应用层自己实现一些保障可靠传输的机制**，实现类似TCP协议的重发机制和拥塞控制算法。有RUDP、RTP、UDT等。

## 2.TIME-WAIT与CLOSE-WAIT状态出现在什么时候？（美团）

主动关闭的一方**收到FIN包，协议层回复ACK**；此时，主动关闭连接的一方，**进入TIME_WAIT状态。** 

TIME_WAIT是主动关闭连接的一方保持的状态，对于服务器来说它本身就是“客户端”，在完成一个爬取任务之后，它就会发起主动关闭连接，从而进入TIME_WAIT的状态，然后在保持这个状态2MSL（max segment lifetime）时间之后，彻底关闭回收资源。为什么2MSL？

1.**防止上一次连接中的包，迷路后重新出现**，影响新连接

2**.可靠的关闭TCP连接。**

在被动关闭连接情况下，在**已经接收到FIN，但是还没有发送自己的FIN的时刻**，连接处于CLOSE_WAIT状态。

出现大量close_wait的现象，主要原因是某种情况下对方关闭了socket链接，但是**我方忙与读或者写，没有关闭连接**。

链接：https://www.nowcoder.com/discuss/207756?type=2

服务器没有收到ack，重发FIN。**如果此时，客户端处于TIME_WAIT状态，那么会响应ack。**如果此时，**客户端已经超过了TIME_WAIT，进入close状态。那么也就意味着客户端的socket 端口关闭了，**这时服务端的FIN到达一个已经关闭的端口，会触发RST复位，服务端直接关闭。  

## 3.为什么需要握手需要四次

因为当Server端收到Client端的SYN连接请求报文后，**可以直接发送SYN+ACK报文**。其中ACK报文是**用来应答的**，SYN报文是用来同步的。但是关闭连接时，当Server端收到FIN报文时，很可能**并不会立即关闭SOCKET，所以只能先回复一个ACK报文**，告诉Client端，"你发的FIN报文我收到了"。

只有**等到我Server端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送**。故需要四步握手。

## 4.TCP超时时间,RTT怎么计算（阿里）

**从前面的TCP重传机制我们知道Timeout的设置对于重传非常重要：**

- 设长了，重发就慢，丢了老半天才重发，没有效率，性能差；
- 设短了，会导致可能并没有丢就重发。于是重发的就快，会增加网络拥塞，导致更多的超时，更多的超时导致更多的重发。

这个超时时间在不同的网络的情况下，根本没有办法设置一个死的值。只能动态地设置。 为了动态地设置，TCP引入了RTT——Round Trip Time，也就是一个数据包从发出去到回来的时间。

- 经典的算法 RFC793
- Jacobaon/Karels 算法

https://blog.csdn.net/wdscq1234/article/details/52505191

## 5. TCP的拥塞控制机制是什么？请简单说说。(腾讯、作业帮)

TCP的拥塞控制采用的是窗口机制，**通过调节窗口的大小实现对数据发送速率的调整**。TCP的发送端维持一个称为拥塞窗口cwnd的变量，单位为字节，用于表示在未收到接收端确认的情况下，可以连续发送的数据字节数。**cwnd的大小取决于网络的拥塞程度，并且动态地发生变化**。拥塞窗口调整的原则是：只要网络没有出现拥塞，就可以增大拥塞窗口，以便将更多的数据发送出去，相当于提高发送速率；一旦网络出现拥塞，拥塞窗口就减小一些，减少注入网络的数据量，从而缓解网络的拥塞。
作者：开点工作室链接：https://www.jianshu.com/p/7d59f9292b03

发送方为一个动态变化的窗口叫做拥塞窗口，拥塞窗口的大小取决于网络的拥塞程度。发送方让自己的发送窗口=拥塞窗口，但是发送窗口不是一直等于拥塞窗口的，在网络情况好的时候，拥塞窗口不断的增加，发送方的窗口自然也随着增加，但是接受方的接受能力有限，在发送方的窗口达到某个大小时就不在发生变化了。

https://www.cnblogs.com/bincoding/p/8976157.html

## 6. TCP跟UDP有啥区别？面向连接？啥叫面向连接？（作业帮）

其一：面向连接分为三个阶段，**第一是建立连接**，在此阶段，发出一个建立连接的请求。只有在连接成功建立之后，才能开始数据传输，这是第二阶段。接着，当数据传输完毕，**必须释放连接**。而面向无连接没有这么多阶段，它直接进行数据传输。 

其二：面向连接的通信具有数据的保序性， 而面向无连接的通信不能保证接收数据的顺序与发送数据的顺序一致。

作者：dgergeg 
原文：https://blog.csdn.net/dgergeg/article/details/50238343 

面向连接的服务，通信双方在进行通信之前，要**先在双方建立起一个完整的可以彼此沟通的通道**，在通信过程中，整个连接的情况一直可以被实时地监控和管理。
非面向连接的服务，不需要预先建立一个联络两个通信节点的连接，需要通信的时候，发送节点就可以往网络上发送信息，让信息自主地在网络上去传，一般在传输的过程中不再加以监控。
作者：守夜no_insomnia链接：https://www.jianshu.com/p/1f9227660b3a

## 7. TCP的序列号是什么（作业帮）

**序号seq** ：用于对**字节流进行编号**，例如序号为 301，表示第一个字节的编号为 301，如果携带的数据长度为 100 字节，那么下一个报文段的序号应为 401。

## 8. TCP粘包和拆包（字节）

- TCP是**基于字节流的**，虽然应用层和TCP传输层之间的数据交互是大小不等的数据块，但是TCP把这些数据块仅仅看成一连串无结构的字节流，**没有边界**；
- 从TCP的帧结构也可以看出，在TCP的首部**没有表示数据长度的字段**

**一个数据包中包含了发送端发送的两个数据包的信息**，这种现象即为粘包

接收端收到了两个数据包，但是这两个数据包**要么是不完整的，要么就是多出来一块**，这种情况即发生了拆包和粘包

拆包和粘包的问题导致**接收端在处理的**时候会非常困难(因为无法区分一个**完整的**数据包)

分包机制一般有两个**通用**的解决方法：

- 特殊字符控制
- 在**包头首都添加数据包的长度**

**UDP没有粘包问题**，但是有丢包和乱序。不完整的包是不会有的，收到的都是完全正确的包。传送的数据单位协议是UDP报文或用户数据报，发送的时候既不合并，也不拆分。

https://segmentfault.com/a/1190000015854646

## 9. 为什么要有TimeWait状态？TimeWait的等待时长一般是多少？（字节）

 假设最终的ACK丢失，主机2将**重发FIN**，主机1必须维护TCP状态信息以便可以**重发最终的ACK**，否则会发送RST，结果主机2认为发生错误。TCP实现必须可靠地终止连接的两个方向(全双工关闭)，主机1必须进入 TIME_WAIT 状态，因为主机1可能面临重发最终ACK的情形。 

2MSL TimeWait等待时长一般为30-90s，为了使数据报在路由器中彻底失效。

https://blog.51cto.com/11859650/1917938

## 10. TCP四次挥手

 ①第一次：主机1（**可以使客户端，也可以是服务器端**），设置**Sequence Number**和**Acknowledgment Number**，向主机2发送一个**FIN**报文段；此时，主机1进入**FIN_WAIT_1**状态；这表示主机1没有数据要发送给主机2了； 

  ②第二次：主机2收到了主机1发送的FIN报文段，向主机1回一个ACK报文段，**Acknowledgment Number**为**Sequence Numbe**r加1**；主机1进入**FIN_WAIT_2状态；主机2告诉主机1，我“同意”你的关闭请求；

  ③第三次：主机2向主机1发送**FIN**报文段，请求关闭连接，同时主机2进入**LAST_ACK**状态；

  ④第四次：主机1收到主机2发送的**FIN**报文段，向主机2发送**ACK**报文段，然后主机1进入**TIME_WAIT**状态；主机2收到主机1的ACK报文段以后，就关闭连接；此时，主机1**等待2MSL后依然没有收到回复**，则证明Server端已正常关闭，那好，主机1也可以关闭连接了。

https://blog.51cto.com/11859650/1917938

## 11. 为什么TIME_WAIT的时间是2MSL，可以变吗？（字节）

TIME_WAIT的状态是**为了等待连接上所有的分组的消失。**单纯的想法，发送端**只需要等待一个MSL就足够了**。这是不够的，假设现在一个MSL的时候，接收端需要发送一个应答，这时候，我们也必须等待这个应答的消失，这个应答的消失也是需要一个MSL，所以我们需要等待2MSL。

https://blog.csdn.net/jike080401/article/details/52980864

不过在实际应用中可以通过设置SO_REUSEADDR选项达到**不必等待2MSL时间结束**再使用此端口。

## 12. TCP滑动窗口机制

接收方通过通告发送方自己的窗口大小，从而**控制发送方的发送速度**，从而达到防止发送方发送速度过快而导致自己被淹没的目的。

https://juejin.im/post/5c9f1dd651882567b4339bce

## 13. TCP3次握手成功建立连接后，假如一方宕机，连接会保持吗（阿里）

当TCP连接的进程在忘记关闭Socket而退出、程序崩溃、或非正常方式结束进程的情况下（Windows客户端），会导致TCP连接的对端进程产生“104: Connection reset by peer”（Linux下）或“10054: An existing connection was forcibly closed by the remote host”（Windows下）错误

当TCP连接的进程机器发生死机、系统突然重启、网线松动或网络不通等情况下**，连接的对端进程可能检测不到任何异常，并最后等待“超时”才断开TCP连接**

当TCP连接的进程正常关闭Socket时，对端进程在检查到TCP关闭事件之前仍然向TCP发送消息，则在Send消息时会产生“32: Broken pipe”（Linux下）或“10053: An established connection was aborted by the software in your host machine”（Windows下）错误

原文链接：https://blog.csdn.net/yusiguyuan/article/details/22515921

## 14. 三次握手会带来什么弊端?（字节）

第三次握手看似多余其实不然，这主要是为了**防止已失效的请求报文段突然又传送到了服务端而产生连接的误判**，造成资源的浪费。

https://www.jianshu.com/p/25f297ba5de1

## 15. SYN Flood 攻击

攻击者首先**伪造地址对 服务器发起SYN请求，服务器回应(SYN+ACK)包，而真实的IP会认为，我没有发送请求，不作回应。服务器没有收到回应，这样的话，服务器不知 道(SYN+ACK)是否发送成功，默认情况下会重试5次（tcp_syn_retries）。**这样的话，对于服务器的内存，带宽都有很大的消耗。攻击者 如果处于公网，可以伪造IP的话，对于服务器就很难根据IP来判断攻击者，给防护带来很大的困难。

## 16. 为什么即时通讯用UDP

它的效率高，速度快，占资源少，但是其传输机制为不可靠传送，必须依靠辅助的算法来完成传输控制。QQ采用的通信协议以UDP为主，辅以TCP协议。

**延迟较短，对数据丢失的处理比较简单**。

https://blog.csdn.net/junjunba2689/article/details/82593124

# UDP 和 TCP 的特点

- 用户数据包协议 UDP（User Datagram Protocol）是**无连接的，尽最大可能交付，没有拥塞控制，面向报文**（对于应用程序传下来的报文不合并也不拆分，只是添加 UDP 首部），支持一对一、一对多、多对多、多对一通信。

- 传输控制协议 TCP（Transmission Control Protocol） 是**面向连接的，提供可靠交付，有流量控制，拥塞控制，提供全双工通信，面向字节流**（把应用层传下来的报文看成字节流，把字节流组织成大小不等的数据块），TCP只支持一对一通信。

# TCP 首部格式

- **序号seq** ：用于对**字节流进行编号**，例如序号为 301，表示第一个字节的编号为 301，如果携带的数据长度为 100 字节，那么下一个报文段的序号应为 401。

- **确认号ack** ：期望收到的下一个报文段的序号。例如 B 正确收到 A 发送来的一个报文段，序号为 501，携带的数据长度为 200 字节，因此 B 期望下一个报文段的序号为 701，B 发送给 A 的确认报文段中确认号就为 701。

- **数据偏移** ：指的是数据部分距离报文段起始处的偏移量，实际上指的是首部的长度。

- **确认 ACK** ：当 ACK=1 时确认号字段有效，否则无效。TCP 规定，在连接建立后所有传送的报文段都必须把 ACK 置 1。

- **同步 SYN** ：在连接建立时用来同步序号。当 SYN=1，ACK=0 时表示这是一个连接请求报文段。若对方同意建立连接，则响应报文中 SYN=1，ACK=1。

- **终止 FIN** ：用来释放一个连接，当 FIN=1 时，表示此报文段的发送方的数据已发送完毕，并要求释放运输连接。

- **窗口** ：窗口值作为接收方让发送方设置其发送窗口的依据。之所以要有这个限制，是因为接收方的数据缓存空间是有限的。

# TCP三次握手和四次挥手

![](https://raw.githubusercontent.com/wuqifan1098/picBed/master/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.png)

- 客户端–发送带有 **SYN 标志**的数据包–一次握手–服务端
- 服务端–发送带有 **SYN/ACK 标志**的数据包–二次握手–客户端
- 客户端–发送带有 **ACK 标志**的数据包–三次握手–服务端

## 为什么要三次握手

第一次握手：Client 什么都不能确认；Server **确认了对方发送正常**

第二次握手：Client 确认了：自己**发送、接收正常**，对方**发送、接收正常**；Server 确认了：自己接收正常，对方发
送正常

第三次握手：Client 确认了：自己发送、接收正常，对方发送、接收正常；Server 确认了：**自己发送、接收正常**，
对方发送接收正常

## 为什么不是两次/四次

两次**服务器端不能确定客户端是否能收到信号**；四次造成了资源的浪费。

## 为什么要传回 SYN

接收端传回发送端所发送的 SYN 是为了告诉发送端，**我接收到的信息确实就是你所发送的信号了**。

## 传了 SYN,为啥还要传 ACK

双方通信无误必须是两者互相发送信息都无误。传了 SYN，证明发送方到接收方的通道没有问题，但是接收方到发送
方的通道还需要 ACK 信号来进行验证。

## 四次挥手

![](https://raw.githubusercontent.com/wuqifan1098/picBed/master/%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B.png)

- 客户端-发送一个 FIN，用来**关闭客户端到服务器的数据传送**
- 服务器-收到这个 FIN，它**发回一 个 ACK，确认序号为收到的序号加1** 。和 SYN 一样，一个 FIN 将占用一个序号
- 服务器-关闭与客户端的连接，发送**一个FIN给客户端**
- 客户端-**发回 ACK 报文确认**，并将确认序号设置为收到序号加1

### 四次挥手状态

- 主动关闭连接的一方，调用close()；协议层发送FIN包 

- 被动关闭的一方收到FIN包后，**协议层回复ACK**；然后被动关闭的一方，**进入CLOSE_WAIT状态**，主动关闭的一方等待对方关闭，则进入FIN_WAIT_2状态；此时，主动关闭的一方 等待 被动关闭一方的应用程序，调用close操作

- 被动关闭的一方**在完成所有数据发送后**，调用close()操作；此时，协议层发送FIN包给主动关闭的一方，等待对方的ACK，被动关闭的一方进入**LAST_ACK状态**；

- 主动关闭的一方收到FIN包，协议层回复ACK；此时，主动关闭连接的一方，**进入TIME_WAIT状态**；而被动关闭的一方，**进入CLOSED状态** 

- 等待2MSL时间，主动关闭的一方，**结束TIME_WAIT，进入CLOSED状态**

### 为什么TIME-WAIT状态必须等待2MSL的时间内？

MSL是Maximum Segment Lifetime英文的缩写，中文可以译为 “**报文最大生存时间**”，他是任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃。2MSL = 2*2mins = 4mins 客户端接收到服务器端的 FIN 报文后进入此状态，此时并不是直接进入 CLOSED 状态，还需要等待一个时间计时器设置的时间 2MSL。这么做有两个理由：

- **确保最后一个确认报文段能够到达B**。如果 B 没收到 A 发送来的确认报文段，那么就会重新发送FIN报文段，接着 A 重传一次确认，重新启动 2MSL 计时器。A 等待一段时间就是为了处理这种情况的发生。
- 等待一段时间是为了让**本连接持续时间内所产生的所有报文段都从网络中消失**，使得**下一个新的连接不会出现旧的连接请求报文段**。

## TCP 滑动窗口

在TCP协议当中窗口机制分为两种：

1.固定的窗口大小

2.滑动窗口

TCP头里有一个字段叫Window，又叫Advertised-Window，这个字段是**接收端告诉发送端自己还有多少缓冲区可以接收数据。于是发送端就可以根据这个接收端的处理能力来发送数据，而不会导致接收端处理不过来。**

我们假设这个固定窗口的大小为1，也就是每次只能发送一个数据，只有接收方对这个数据进行了确认后才能发送第二个数据。在图中我们可以看到，发送方每发送一个数据接收方就要给发送方一个ACK对这个数据进行确认。只有接收了这个确认数据以后发送方才能传输下个数据。

存在的问题：**如果窗口过小，当传输比较大的数据的时候需要不停的对数据进行确认，这个时候就会造成很大的延迟**。

如果窗口过大，我们假设发送方一次发送100个数据，但接收方只能处理50个数据，这样每次都只对这50个数据进行确认。发送方下一次还是发送100个数据，但接受方还是只能处理50个数据。**这样就避免了不必要的数据来拥塞我们的链路**。

因此，我们引入了滑动窗口

滑动窗口通俗来讲就是一种**流量控制技术**。

它本质上是描述接收方的TCP数据报缓冲区大小的数据，发送方根据这个数据来计算自己最多能发送多长的数据，如果发送方收到接收方的窗口大小为0的TCP数据报，那么发送方将停止发送数据，等到接收方发送窗口大小不为0的数据报的到来

窗口是缓存的一部分，用来**暂时存放字节流**。发送方和接收方各有一个窗口，接收方通过 TCP 报文段中的窗口字段告诉发送方自己的窗口大小，**发送方根据这个值和其它信息设置自己的窗口大小**。**第一次发送数据这个时候的窗口大小是根据链路带宽的大小来决定的。**

发送窗口内的字节都允许被发送，接收窗口内的字节都允许被接收。如果发送**窗口左部的字节已经发送并且收到了确认，那么就将发送窗口向右滑动一定距离，直到左部第一个字节不是已发送并且已确认的状态**；接收窗口的滑动类似，接收窗口左部字节已经发送确认并交付主机，就向右滑动接收窗口。

接收窗口**只会对窗口内最后一个按序到达的字节进行确认**，例如接收窗口已经收到的字节为 {31, 32, 34, 35}，其中 {31, 32} 按序到达，而 {34, 35} 就不是，因此只对字节 32 进行确认。发送方得到一个字节的确认之后，就知道这个字节之前的所有字节都已经被接收。

## TCP重传机制

注意，接收端给发送端的Ack确认只会确认最后一个连续的包，比如，发送端发了1,2,3,4,5一共五份数据，接收端收到了1，2，于是回ack 3，然后收到了4（注意此时3没收到），此时的TCP会怎么办？我们要知道，因为正如前面所说的，SeqNum和Ack是以字节数为单位，所以ack的时候，**不能跳着确认，只能确认最大的连续收到的包**，不然，发送端就以为之前的都收到了。

### 超时重传机制

一种是不回ack，死等3，**当发送方发现收不到3的ack超时后**，会重传3。一旦接收方收到3后，会ack 回 4——意味着3和4都收到了。

但是，这种方式会有比较严重的问题，那就是因为要死等3，所以会导致4和5即便已经收到了，而发送方也完全不知道发生了什么事，因为没有收到Ack，所以，发送方可能会悲观地认为也丢了，所以有可能也会导致4和5的重传。

对此有两种选择：

- 一种是仅重传timeout的包。也就是第3份数据。
- 另一种是重传timeout后所有的数据，也就是第3，4，5这三份数据。

### 快速重传机制

TCP引入了一种叫Fast Retransmit 的算法，**不以时间驱动，而以数据驱动重传。**也就是说，如果，包没有连续到达，就ack最后那个可能被丢了的包，如果**发送方连续收到3次相同的ack，就重传**。Fast Retransmit的好处是不用等timeout了再重传。

## TCP 拥塞控制

如果网络上的延时突然增加，那么，TCP对这个事做出的应对只有重传数据，但是，重传会导致网络的负担更重，于是会导致更大的延迟以及更多的丢包，于是，这个情况就会进入恶性循环被不断地放大。试想一下，如果一个网络内有成千上万的TCP连接都这么行事，那么马上就会形成“网络风暴”，TCP这个协议就会拖垮整个网络。这是一个灾难。

所以，TCP不能忽略网络上发生的事情，而无脑地一个劲地重发数据，对网络造成更大的伤害。对此TCP的设计理念是：**TCP不是一个自私的协议，当拥塞发生的时候，要做自我牺牲。就像交通阻塞一样，每个车都应该把路让出来，而不要再去抢路了。**

拥塞控制主要是四个算法：**1）慢启动，2）拥塞避免，3）拥塞发生，4）快速恢复。**

### **拥塞控制 和 流量控制 的区别？**

1. 拥塞控制：拥塞控制是**作用于网络的，它是防止过多的数据注入到网络中，避免出现网络负载过大的情况；**
2. 流量控制：流量控制是**作用于接收者的，它是控制发送者的发送速度从而使接收者来得及接收。** PS：拥塞控制是针对于网络而言的，它是防止往网络中写入太多分组，从而导致网络拥塞的情况；而流量控制是针对接收者的，它是通过控制发送者的发送速度保证接收者能够来得及接收。

### **慢开始算法 和 拥塞避免算法**

- 发送方维护一个发送窗口，发送窗口的大小取决于网络的拥塞情况和接收窗口的大小，发送窗口是动态变化的。
- 发送方还维护一个慢开始门限 
  1. 发送窗口 < 慢开始门限：使用慢开始算法
  2. 发送窗口 > 慢开始门限：使用拥塞避免算法
  3. 发送窗口 = 慢开始门限：使用慢开始算法或拥塞避免算法
- 算法的具体过程： 
  1. 通信开始时，发送方的发送窗口设为1，并发送第一个分组M1；
  2. 接收方收到M1后，返回确认应答，此时发送方发送窗口扩大两倍，并发送M2、M3；（即，发送方每次收到确认应答后，都将发送窗口设为当前值的两倍）
  3. 若发送窗口>慢开始门限，则使用拥塞避免算法，每次收到确认应答后都将发送窗口+1；
  4. 若发送方出现了超时重传，则表明网络出现拥塞，此时： a）慢开始门限设为当前发送窗口的一半； b）发送窗口设为1； c）启用拥塞避免算法； PS：发送超时重传时，发送窗口有可能已经超过了慢开始门限，也有可能还没超过；此时不管何种情况，都一律启用拥塞避免算法，并执行上述三步操作！
- 慢开始算法的作用：**慢开始算法将发送窗口从小扩大，而且按指数级扩大，从而避免一开始就往网络中注入过多的分组从而导致拥塞**；它将窗口慢慢扩大的过程其实也在探测网络拥塞情况的过程，当发现出现拥塞时，及时降低发送速度，从而减缓网络拥塞。
- 拥塞避免算法的作用：拥塞避免算法使发送窗口以线性方式增长，而非指数级增长，从而使网络更加不容易发生拥塞。
- AIMD算法（加法增大乘法减小算法） 慢开始算法 和 拥塞避免算法 还有个名称叫做『加法增大乘法减小算法』。 
  - 加法增加：指的是拥塞避免算法，使得发送窗口以线性的方式增长；
  - 乘法减小：指的是不管当前正使用慢开始算法还是拥塞避免算法，只要发生拥塞时，慢开始门限将会变成当前窗口的一半。

### **快重传算法 和 快恢复算法**

- 上述慢开始算法和拥塞避免算法能**保证网络出现拥塞时进行相应的处理**，而快重传和快恢复是一种拥塞预防的方式，此时网络可能尚未出现拥塞，但已经有拥塞的征兆，因此得作出一些预防措施。
- 快重传原理：因为TCP具有累计确认的能力，因此接收者收到一个分组的时候不会立即发出应答，可能需要等待收到多个分组之后再同一发出累计确认。但快重传算法就要求，接收者如果接收到一个乱序的分组的话，就必须立即发出前一个正确分组的确认应答，这样能让发送者尽早地知道有一个分组可能丢失。
- 快恢复原理：当发送者**收到同一个分组的三个确认应答后，就基本可以判断这个分组已经丢失了**；这时候无需等待超时，直接执行『乘法减小加法增大』： 
  1. 将慢开始门限减半；
  2. 将发送窗口减半（不设为1）；
  3. 使用拥塞避免算法；


作者：大闲人柴毛毛链接：https://juejin.im/post/5aa4de666fb9a028e11f9332