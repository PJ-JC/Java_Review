# 面试题

## 1.tcp如何保证可靠性？（阿里）如果想用udp又想保证可靠性该如何？

- 校验和
- 序列号
- 确认应答
- 超时重传
- 连接管理
- 流量控制
- 拥塞控制

由于在传输层UDP已经是不可靠的连接，那就要**在应用层自己实现一些保障可靠传输的机制**，实现类似TCP协议的重发机制和拥塞控制算法。
有RUDP、RTP、UDT等。

## 2.TIME-WAIT与CLOSE-WAIT状态出现在什么时候？（美团）

主动关闭的一方**收到FIN包，协议层回复ACK**；此时，主动关闭连接的一方，进入TIME_WAIT状态。 

TIME_WAIT是主动关闭连接的一方保持的状态，对于服务器来说它本身就是“客户端”，在完成一个爬取任务之后，它就会发起主动关闭连接，从而进入TIME_WAIT的状态，然后在保持这个状态2MSL（max segment lifetime）时间之后，彻底关闭回收资源。为什么2MSL？

1.防止上一次连接中的包，迷路后重新出现，影响新连接

2.可靠的关闭TCP连接。

在被动关闭连接情况下，在**已经接收到FIN，但是还没有发送自己的FIN的时刻**，连接处于CLOSE_WAIT状态。

出现大量close_wait的现象，主要原因是某种情况下对方关闭了socket链接，但是**我方忙与读或者写，没有关闭连接**。

## 3.为什么需要握手需要四次

因为当Server端收到Client端的SYN连接请求报文后，**可以直接发送SYN+ACK报文**。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当Server端收到FIN报文时，很可能**并不会立即关闭SOCKET，所以只能先回复一个ACK报文**，告诉Client端，"你发的FIN报文我收到了"。只有**等到我Server端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送**。故需要四步握手。

## 4.TCP超时时间,RTT怎么计算（阿里）

**从前面的TCP重传机制我们知道Timeout的设置对于重传非常重要：**

- 设长了，重发就慢，丢了老半天才重发，没有效率，性能差；
- 设短了，会导致可能并没有丢就重发。于是重发的就快，会增加网络拥塞，导致更多的超时，更多的超时导致更多的重发。

这个超时时间在不同的网络的情况下，根本没有办法设置一个死的值。只能动态地设置。 为了动态地设置，TCP引入了RTT——Round Trip Time，也就是一个数据包从发出去到回来的时间。

- 经典的算法 RFC793
- Jacobaon/Karels 算法

https://blog.csdn.net/wdscq1234/article/details/52505191

## 5. TCP的拥塞控制机制是什么？请简单说说。(腾讯、作业帮)

TCP的拥塞控制采用的是窗口机制，通过调节窗口的大小实现对数据发送速率的调整。TCP的发送端维持一个称为拥塞窗口cwnd的变量，单位为字节，用于表示在未收到接收端确认的情况下，可以连续发送的数据字节数。cwnd的大小取决于网络的拥塞程度，并且动态地发生变化。拥塞窗口调整的原则是：只要网络没有出现拥塞，就可以增大拥塞窗口，以便将更多的数据发送出去，相当于提高发送速率；一旦网络出现拥塞，拥塞窗口就减小一些，减少注入网络的数据量，从而缓解网络的拥塞。
作者：开点工作室链接：https://www.jianshu.com/p/7d59f9292b03

发送方为一个动态变化的窗口叫做拥塞窗口，拥塞窗口的大小取决于网络的拥塞程度。发送方让自己的发送窗口=拥塞窗口，但是发送窗口不是一直等于拥塞窗口的，在网络情况好的时候，拥塞窗口不断的增加，发送方的窗口自然也随着增加，但是接受方的接受能力有限，在发送方的窗口达到某个大小时就不在发生变化了。

https://www.cnblogs.com/bincoding/p/8976157.html

## 6. TCP跟UDP有啥区别？面向连接？啥叫面向连接？（作业帮）

其一：面向连接分为三个阶段，第一是建立连接，在此阶段，发出一个建立连接的请求。只有在连接成功建立之后，才能开始数据传输，这是第二阶段。接着，当数据传输完毕，必须释放连接。而面向无连接没有这么多阶段，它直接进行数据传输。 

其二：面向连接的通信具有数据的保序性， 而面向无连接的通信不能保证接收数据的顺序与发送数据的顺序一致。

作者：dgergeg 
原文：https://blog.csdn.net/dgergeg/article/details/50238343 

面向连接的服务，通信双方在进行通信之前，要先在双方建立起一个完整的可以彼此沟通的通道，在通信过程中，整个连接的情况一直可以被实时地监控和管理。
非面向连接的服务，不需要预先建立一个联络两个通信节点的连接，需要通信的时候，发送节点就可以往网络上发送信息，让信息自主地在网络上去传，一般在传输的过程中不再加以监控。
作者：守夜no_insomnia链接：https://www.jianshu.com/p/1f9227660b3a

## 7. TCP的序列号是什么（作业帮）

**序号seq** ：用于对**字节流进行编号**，例如序号为 301，表示第一个字节的编号为 301，如果携带的数据长度为 100 字节，那么下一个报文段的序号应为 401。

# UDP 和 TCP 的特点

- 用户数据包协议 UDP（User Datagram Protocol）是**无连接的，尽最大可能交付，没有拥塞控制，面向报文**（对于应用程序传下来的报文不合并也不拆分，只是添加 UDP 首部）。

- 传输控制协议 TCP（Transmission Control Protocol） 是**面向连接的，提供可靠交付，有流量控制，拥塞控制，提供全双工通信，面向字节流**（把应用层传下来的报文看成字节流，把字节流组织成大小不等的数据块）

# TCP 首部格式

- **序号seq** ：用于对**字节流进行编号**，例如序号为 301，表示第一个字节的编号为 301，如果携带的数据长度为 100 字节，那么下一个报文段的序号应为 401。

- **确认号ack** ：期望收到的下一个报文段的序号。例如 B 正确收到 A 发送来的一个报文段，序号为 501，携带的数据长度为 200 字节，因此 B 期望下一个报文段的序号为 701，B 发送给 A 的确认报文段中确认号就为 701。

- **数据偏移** ：指的是数据部分距离报文段起始处的偏移量，实际上指的是首部的长度。

- **确认 ACK** ：当 ACK=1 时确认号字段有效，否则无效。TCP 规定，在连接建立后所有传送的报文段都必须把 ACK 置 1。

- **同步 SYN** ：在连接建立时用来同步序号。当 SYN=1，ACK=0 时表示这是一个连接请求报文段。若对方同意建立连接，则响应报文中 SYN=1，ACK=1。

- **终止 FIN** ：用来释放一个连接，当 FIN=1 时，表示此报文段的发送方的数据已发送完毕，并要求释放运输连接。

- **窗口** ：窗口值作为接收方让发送方设置其发送窗口的依据。之所以要有这个限制，是因为接收方的数据缓存空间是有限的。

# TCP三次握手和四次挥手

![](https://raw.githubusercontent.com/wuqifan1098/picBed/master/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.png)

- 客户端–发送带有 **SYN 标志**的数据包–一次握手–服务端
- 服务端–发送带有 **SYN/ACK 标志**的数据包–二次握手–客户端
- 客户端–发送带有 **ACK 标志**的数据包–三次握手–服务端

## 为什么要三次握手

第一次握手：Client 什么都不能确认；Server **确认了对方发送正常**

第二次握手：Client 确认了：自己**发送、接收正常**，对方**发送、接收正常**；Server 确认了：自己接收正常，对方发
送正常

第三次握手：Client 确认了：自己发送、接收正常，对方发送、接收正常；Server 确认了：**自己发送、接收正常**，
对方发送接收正常

## 为什么不是两次/四次

两次服务器端不能确定客户端是否能收到信号；四次造成了资源的浪费。

## 为什么要传回 SYN

接收端传回发送端所发送的 SYN 是为了告诉发送端，我接收到的信息确实就是你所发送的信号了。

## 传了 SYN,为啥还要传 ACK

双方通信无误必须是两者互相发送信息都无误。传了 SYN，证明发送方到接收方的通道没有问题，但是接收方到发送
方的通道还需要 ACK 信号来进行验证。

## 四次挥手

![](https://raw.githubusercontent.com/wuqifan1098/picBed/master/%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B.png)

- 客户端-发送一个 FIN，用来**关闭客户端到服务器的数据传送**
- 服务器-收到这个 FIN，它**发回一 个 ACK，确认序号为收到的序号加1** 。和 SYN 一样，一个 FIN 将占用一个序号
- 服务器-关闭与客户端的连接，发送**一个FIN给客户端**
- 客户端-**发回 ACK 报文确认**，并将确认序号设置为收到序号加1

### 四次挥手状态

- 主动关闭连接的一方，调用close()；协议层发送FIN包 

- 被动关闭的一方收到FIN包后，协议层回复ACK；然后被动关闭的一方，进入CLOSE_WAIT状态，主动关闭的一方等待对方关闭，则进入FIN_WAIT_2状态；此时，主动关闭的一方 等待 被动关闭一方的应用程序，调用close操作

- 被动关闭的一方在完成所有数据发送后，调用close()操作；此时，协议层发送FIN包给主动关闭的一方，等待对方的ACK，被动关闭的一方进入LAST_ACK状态；

- 主动关闭的一方收到FIN包，协议层回复ACK；此时，主动关闭连接的一方，进入TIME_WAIT状态；而被动关闭的一方，进入CLOSED状态 

- 等待2MSL时间，主动关闭的一方，结束TIME_WAIT，进入CLOSED状态

### 为什么TIME-WAIT状态必须等待2MSL的时间内？

MSL是Maximum Segment Lifetime英文的缩写，中文可以译为 “**报文最大生存时间**”，他是任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃。2MSL = 2*2mins = 4mins 客户端接收到服务器端的 FIN 报文后进入此状态，此时并不是直接进入 CLOSED 状态，还需要等待一个时间计时器设置的时间 2MSL。这么做有两个理由：

- **确保最后一个确认报文段能够到达B**。如果 B 没收到 A 发送来的确认报文段，那么就会重新发送连接释放请求报文段，接着 A 重传一次确认，重新启动 2MSL 计时器。A 等待一段时间就是为了处理这种情况的发生。
- 等待一段时间是为了让**本连接持续时间内所产生的所有报文段都从网络中消失**，使得**下一个新的连接不会出现旧的连接请求报文段**。

## TCP 滑动窗口

在TCP协议当中窗口机制分为两种：

1.固定的窗口大小

2.滑动窗口

TCP头里有一个字段叫Window，又叫Advertised-Window，这个字段是**接收端告诉发送端自己还有多少缓冲区可以接收数据。于是发送端就可以根据这个接收端的处理能力来发送数据，而不会导致接收端处理不过来。**

我们假设这个固定窗口的大小为1，也就是每次只能发送一个数据，只有接收方对这个数据进行了确认后才能发送第二个数据。在图中我们可以看到，发送方每发送一个数据接收方就要给发送方一个ACK对这个数据进行确认。只有接收了这个确认数据以后发送方才能传输下个数据。

存在的问题：**如果窗口过小，当传输比较大的数据的时候需要不停的对数据进行确认，这个时候就会造成很大的延迟**。

如果窗口过大，我们假设发送方一次发送100个数据，但接收方只能处理50个数据，这样每次都只对这50个数据进行确认。发送方下一次还是发送100个数据，但接受方还是只能处理50个数据。**这样就避免了不必要的数据来拥塞我们的链路**。

因此，我们引入了滑动窗口

### 概述

滑动窗口通俗来讲就是一种**流量控制技术**。

它本质上是描述接收方的TCP数据报缓冲区大小的数据，发送方根据这个数据来计算自己最多能发送多长的数据，如果发送方收到接收方的窗口大小为0的TCP数据报，那么发送方将停止发送数据，等到接收方发送窗口大小不为0的数据报的到来

窗口是缓存的一部分，用来**暂时存放字节流**。发送方和接收方各有一个窗口，接收方通过 TCP 报文段中的窗口字段告诉发送方自己的窗口大小，**发送方根据这个值和其它信息设置自己的窗口大小**。**第一次发送数据这个时候的窗口大小是根据链路带宽的大小来决定的。**

发送窗口内的字节都允许被发送，接收窗口内的字节都允许被接收。如果发送窗口左部的字节已经发送并且收到了确认，那么就将发送窗口向右滑动一定距离，直到左部第一个字节不是已发送并且已确认的状态；接收窗口的滑动类似，接收窗口左部字节已经发送确认并交付主机，就向右滑动接收窗口。

接收窗口只会对窗口内最后一个按序到达的字节进行确认，例如接收窗口已经收到的字节为 {31, 32, 34, 35}，其中 {31, 32} 按序到达，而 {34, 35} 就不是，因此只对字节 32 进行确认。发送方得到一个字节的确认之后，就知道这个字节之前的所有字节都已经被接收。

## TCP重传机制

注意，接收端给发送端的Ack确认只会确认最后一个连续的包，比如，发送端发了1,2,3,4,5一共五份数据，接收端收到了1，2，于是回ack 3，然后收到了4（注意此时3没收到），此时的TCP会怎么办？我们要知道，因为正如前面所说的，SeqNum和Ack是以字节数为单位，所以ack的时候，**不能跳着确认，只能确认最大的连续收到的包**，不然，发送端就以为之前的都收到了。

### 超时重传机制

一种是不回ack，死等3，当发送方发现收不到3的ack超时后，会重传3。一旦接收方收到3后，会ack 回 4——意味着3和4都收到了。

但是，这种方式会有比较严重的问题，那就是因为要死等3，所以会导致4和5即便已经收到了，而发送方也完全不知道发生了什么事，因为没有收到Ack，所以，发送方可能会悲观地认为也丢了，所以有可能也会导致4和5的重传。

对此有两种选择：

- 一种是仅重传timeout的包。也就是第3份数据。
- 另一种是重传timeout后所有的数据，也就是第3，4，5这三份数据。

### 快速重传机制

TCP引入了一种叫Fast Retransmit 的算法，**不以时间驱动，而以数据驱动重传。**也就是说，如果，包没有连续到达，就ack最后那个可能被丢了的包，如果发送方连续收到3次相同的ack，就重传。Fast Retransmit的好处是不用等timeout了再重传。

## TCP 拥塞控制

如果网络上的延时突然增加，那么，TCP对这个事做出的应对只有重传数据，但是，重传会导致网络的负担更重，于是会导致更大的延迟以及更多的丢包，于是，这个情况就会进入恶性循环被不断地放大。试想一下，如果一个网络内有成千上万的TCP连接都这么行事，那么马上就会形成“网络风暴”，TCP这个协议就会拖垮整个网络。这是一个灾难。

所以，TCP不能忽略网络上发生的事情，而无脑地一个劲地重发数据，对网络造成更大的伤害。对此TCP的设计理念是：**TCP不是一个自私的协议，当拥塞发生的时候，要做自我牺牲。就像交通阻塞一样，每个车都应该把路让出来，而不要再去抢路了。**

拥塞控制主要是四个算法：**1）慢启动，2）拥塞避免，3）拥塞发生，4）快速恢复。**
