# 对象的创建

java程序中创建对象的常用方式是:

```
`Object obj = ``new` `Object();`
```

该行代码的执行过程如下:

![](https://raw.githubusercontent.com/wuqifan1098/picBed/master/%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA%E8%BF%87%E7%A8%8B.png)

从图中我们可以发现**对象创建的步骤**如下

1. 执行new执行
2. 检查这个指令参数是否能够在常量池中定位到一个类的符号引用，并且检查这个符号引用所代表的类是否已经被加载，解析和初始化。
3. 如果该类没有被加载则先执行类的加载操作
4. 如果该类已经被加载，则开始给该对象在jvm的堆中分配内存。分配规则后面介绍
5. 虚拟机初始化操作，虚拟机对分配的空间初始化为零值。
6. 执行init方法，初始化对象的属性，至此对象被创建完成。
7. java虚拟机栈中的Reference执行我们刚刚创建的对象。

在上面的过程中的类加载的过程，后面会单独介绍，而内存分配这块我们来介绍下

# **内存的分配原则**

内存分配的基本原则：

| 序号 | 介绍                                                         |
| :--- | :----------------------------------------------------------- |
| 1    | 优先在Eden分配,如果Eden空间不足虚拟机则会进行一次MinorGC     |
| 2    | 大对象直接接入老年代,很长的字符串或数组                      |
| 3    | 长期存活的对象进入老年代，每个对象都有一个age，当age到达设定的年龄的时候就会进入老年代，默认是15岁 |

**内存的分配方法**

内存分配的方法有两种:指针碰撞(Bump the Pointer)和空闲列表(Free List)

| 分配方法 | 说明             | 收集器                      |
| :------- | :--------------- | :-------------------------- |
| 指针碰撞 | 内存地址是连续的 | Serial和ParNew收集器        |
| 空闲列表 | 内存地址不连续   | CMS收集器和Mark-Sweep收集器 |

**内存分配的安全问题**

在分配内存的同时，存在线程安全的问题，即虚拟机给A线程分配内存过程中，指针未修改，B线程可能同时使用了同样一块内存。
在JVM中有两种解决办法：

1. 同步处理，即CAS(compare & swap)搭配失败重试的方式
2. 将内存分配的动作按线程分配到不同空间中，每个线程都有一小块内存，成为**本地线程分配缓冲**(Thread Local Allocation Buffer即TLAB)。

# **对象的访问定位**

建立对象是为了使用对象,java程序是通过栈上的reference数量来操作堆上的具体的对象，具体操作对象的方式有两种：

**通过句柄访问对象**

![](https://raw.githubusercontent.com/wuqifan1098/picBed/master/%E5%8F%A5%E6%9F%84%E8%AE%BF%E9%97%AE%E5%AF%B9%E8%B1%A1.png)

**通过直接指针访问对象**

![](https://raw.githubusercontent.com/wuqifan1098/picBed/master/%E6%8C%87%E9%92%88%E8%AE%BF%E9%97%AE%E5%AF%B9%E8%B1%A1.png)

两种方式的比较

| 方式     | 优点                                 |
| :------- | :----------------------------------- |
| 句柄     | 稳定，对象被移动只要修改句柄中的地址 |
| 直接指针 | 访问速度快，节省了一次指针定位的开销 |

https://www.jb51.net/article/157742.htm