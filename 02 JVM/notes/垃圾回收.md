# 面试题

## 1.日常中使用强引用的时候会导致 gc 无法回收，虚拟机内存从而会抛出一个什么异常或错误？（扁鹊）

OutOfMemoryError错误

## 2.说一下一个对象从 Eden 区到 From Survivor ，再到 To Survivor 区，再到老年代的过程（贝贝）

所有的新生代首先会**在Eden区进行内存分配**，当Eden区满时会进行一次**Minor GC操作**，将Eden区进行回收，此时判断存活的对象会**被复制进入Survivor from区（年龄加1）**，紧接着进行GC，Eden区中**所有存活的对象都会被复制到“To”**，而在“From”区中，**仍存活的对象会根据他们的年龄值来决定去向**。年龄达到一定值(年龄阈值，可以通过-XX:MaxTenuringThreshold来设置)的对象会被移动到年老代中，没有达到阈值的对象会被复制到“To”区域。经过这次GC后，Eden区和From区已经被清空。这个时候，**“From”和“To”会交换他们的角色**，也就是新的“To”就是上次GC前的“From”，新的“From”就是上次GC前的“To”。不管怎样，都会保证名为To的Survivor区域是空的。Minor GC会一直重复这样的过程，直到“To”区被填满，**“To”区被填满之后，会将所有对象移动到年老代中。**

## 3.JVM垃圾回收过程，CMS在哪个阶段会停顿，哪个阶段停顿的时间最长？

并发标记

它的运作过程更复杂一些，整个过程分为四个步骤：

- 初始标记(CMS initial mark)
- 并发标记(CMS concurrent mark)
- 重新标记(CMS remark)
- 并发清除(CMS concurrent sweep)

**初始标记、重新标记这两个步骤仍然需要“Stop the World”。**初始标记仅仅只是标记一下GC **Roots能直接关联到的对象**，速度很快，并发标记阶段就是进行GC Roots Tracing的过程。而重新标记阶段则是为了**修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录。**这个阶段的停顿实际一般会比初始标记阶段稍长一些，但远比并发标记时间短。

深入CMS https://blog.csdn.net/J080624/article/details/86693275

## 4.GC机制

程序计数器、虚拟机栈和本地方法栈这三个区域属于线程私有的，只存在于线程的生命周期内，线程结束之后也会消失，因此不需要对这三个区域进行垃圾回收。

垃圾回收**主要是针对 Java 堆和方法区**进行。

## 5.像我们日常当中是使用哪一个引用？

强引用。

## 6.如何判断一个类是无用的类

- 该类**所有的实例都已经被回收**，也就是 Java 堆中不存在该类的任何实例。
- **加载该类的 ClassLoader **已经被回收。
- 该类对应的 java.lang.Class **对象没有在任何地方被引用**，无法在任何地方通过反射访问该类的方法。

## 7.**为什么要有Survivor区**

如果没有Survivor，Eden区每进行一次Minor GC，存活的对象就会被送到老年代。老年代很快被填满，触发Major GC（因为Major GC一般伴随着Minor GC，也可以看做触发了Full GC）。老年代的内存空间远大于新生代，进行一次Full GC消耗的时间比Minor GC长得多。你也许会问，执行时间长有什么坏处？频发的Full GC消耗的时间是非常可观的，这一点会**影响大型程序的执行和响应速度**，更不要说某些连接会因为超时发生连接错误了。

**Survivor的存在意义，就是减少被送到老年代的对象，进而减少Full GC的发生，Survivor的预筛选保证，只有经历16次Minor GC还能在新生代中存活的对象，才会被送到老年代。**

## 8.**为什么要设置两个Survivor区**

**设置两个Survivor区最大的好处就是解决了碎片化**

刚刚新建的对象在Eden中，一旦Eden满了，触发一次Minor GC，Eden中的存活对象就会被移动到Survivor区。这样继续循环下去，下一次Eden满了的时候，问题来了，此时进行Minor GC，Eden和Survivor各有一些存活对象，如果此时把Eden区的存活对象硬放到Survivor区，很明显这两部分对象所占有的内存是不连续的，也就导致了内存**碎片化**。 

**永远有一个survivor space是空的，另一个非空的survivor space无碎片**。

复制算法保证了S1中来自S0和Eden两部分的**存活对象占用连续的内存空间**，避免了碎片化的发生

Survivor为什么不分更多块呢？比方说分成三个、四个、五个?显然，如果Survivor区再细分下去，每一块的空间就会比较小，很容易导致Survivor区满，因此，我认为两块Survivor区是经过权衡之后的最佳方案。

设置Survivor空间的目的是让那些中等寿命的对象尽量在 Minor GC 时被干掉，最终**在总体上减少虚拟机的垃圾收集过程对用户程序的影响。**

Survivor的存在意义，就是减少被送到老年代的对象，进而减少Full GC的发生，Survivor的预筛选保证，只有经历16次Minor GC还能在新生代中存活的对象，才会被送到老年代。

https://blog.csdn.net/bntx2jsqfehy7/article/details/79606795

## 9. Java如何立即启动垃圾回收？（贝贝）

Java里提供了一个System.gc()方法，使用这个方法可以强制启动垃圾回收器来会收垃圾。

## 10. 为什么要分代收集

**不同的对象的生命周期是不一样的**。因此，不同生命周期的对象可以采取不同的收集方式，以便提高回收效率。

https://blog.51cto.com/332532/1773081

## 11. CMS用了什么优化机制



## 12. CMS和G1的区别

两者都是**并发，低停顿**的收集器

CMS：以获取**最短回收停顿时间**为目标的收集器，基于并发“**标记清理**”实现，会产生大量的内存空间碎片；**对CPU资源敏感**，并发阶段虽然不会导致用户线程停顿，但会占用一部分线程使应用程序变慢；**无法处理浮动垃圾：**并发清理过程中，用户线程产生的垃圾，只有等下一次GC才能清除。CMS失败后会**使用备案的SerialOld处理器**。


G1将整个Java堆划分为**多个大小相等的独立区域（Region）**，基于**“标记整理”**实现，G1运作期间**不会产生内存空间碎片**，可以充分利用多个CPU来缩短stop-The-World的停顿时间，G1除了追求低停顿外，还能建立**可预测的停顿时间模型**，在最后筛选回收阶段，对每个region里的回收对象价值（回收该区域的时间消耗和能得到的内存比值）最后进行排序，用户可以自定义停顿时间，那么G1就可以对部分的region进行回收！这使得停顿时间是用户自己可以控制的。G1可以**不需要其它收集器配合就能独立管理整个GC堆**

<https://blog.csdn.net/Fly_as_tadpole/article/details/85047616>

## 13. 可达性分析实现

有一系列“GCRoots”起点，从这些点开始向下搜索，走过的路径称为“引用链”。若一个对象没有任何引用链可到达GC Roots，那么该对象就是不可用的，即使该对象还与其他对象相关联。

被启动类（bootstrap加载器）加载的类和创建的对象

jvm运行时**方法区类静态变量**(static)引用的对象

jvm运行时**方法区常量池**引用的对象

jvm当前运行线程中的**虚拟机栈变量表引用的对象**

**本地方法栈中(jni)**引用的对象

## 14.可达性分析完后，会立即回收吗（美团）

不会

经可达性分析算法所标记出的对象，会**进行一次筛选（根据finalize方法）**。若经过筛选，判定可回收，那么就会立即回收；若判定没有必要回收，那么就将对象放入F-Queue队列中，进行二次筛查。

二次筛查**会执行对象的finalize()方法。**若对象在这个**过程重新与引用链上的任何一个对象建立关联，那么该对象就会从回收集合中移除**。否则，对象会被回收。


# 1 堆内存分配策略和回收策略

## 1.1 对象优先在eden区分配

目前主流的垃圾收集器都会采用**分代回收算法**，因此需要将堆内存分为新生代和老年代，这样我们就可以根据各个年代的特点选择合适的垃圾收集算法。

大多数情况下，对象在新生代中 eden 区分配。当 eden 区没有足够空间进行分配时，虚拟机将发起一次**Minor GC**.下面我们来进行实际测试以下。

在测试之前我们先来看看 Minor GC和Full GC 有什么不同呢？

- 新生代GC（Minor GC）:指**发生新生代的的垃圾收集动作**，Minor GC非常频繁，回收速度一般也比较快。
- 老年代GC（Major GC/Full GC）:指发生在**老年代的GC**，出现了Major GC经常会伴随至少一次的Minor GC（并非绝对），Major GC的速度一般会比Minor GC的慢10倍以上。

## 1.2 大对象直接进入老年代

大对象就是需要大量连续内存空间的对象（比如：字符串、数组）。

**为什么要这样呢？**

为了避免为大对象分配内存时由于分配担保机制带来的复制而降低效率。

## 1.3 长期存活的对象将进入老年代

如果对象在 Eden 出生并经过第一次 Minor GC 后仍然能够存活，并且能被 Survivor 容纳的话，将被移动到 Survivor 空间中，并将对象年龄设为1.对象在 Survivor 中每熬过一次 MinorGC,年龄就增加1岁，当它的年龄增加到一定程度（默认为15岁），就会被晋升到老年代中。对象晋升到老年代的年龄阈值，可以通过参数 -XX:MaxTenuringThreshold 来设置。

## 1.4 动态对象年龄判定

## 1.5 什么时候进行Minor GC，Full GC

Minor GC：发生在新生代上，因为新生代对象存活时间很短，因此 Minor GC 会频繁执行，执行的速度一般也会比较快。

1.  新生代中的垃圾收集动作，采用的是复制算法
1.  对于较大的对象，在 Minor GC 的时候可以直接进入老年代

Full GC：发生在老年代上，**老年代对象其存活时间长**，因此 Full GC 很少执行，**执行速度会比 Minor GC 慢很多**。

1. Full GC 是发生在老年代的垃圾收集动作，采用的是 **标记-清除/整理** 算法。
1. 由于老年代的对象几乎都是在 Survivor 区熬过来的，不会那么容易死掉。因此 Full GC 发生的次数不会有 Minor GC 那么频繁，并且 Time(Full GC)>Time(Minor GC)

- Minor GC：回收新生代，因为新生代对象存活时间很短，因此 Minor GC **会频繁执行**，**执行的速度一般也会比较快。**
- Full GC：回收老年代和新生代，老年代对象其存活时间长，因此 Full GC 很少执行，执行速度会比 Minor GC 慢很多。

## 1.6 Full GC 的触发条件

1. 调用 System.gc()
2. 老年代空间不足
3. 空间分配担保失败
4. JDK 1.7 及以前的永久代空间不足
5. Concurrent Mode Failure

# 2.判断一个对象是否可被回收

## 2.1 引用计数法

给对象中添加一个引用计数器，每当有一个地方引用它，计数器就加1；当引用失效，计数器就减1；任何时候计数器为0的对象就是不可能再被使用的。

**这个方法实现简单，效率高，但是目前主流的虚拟机中并没有选择这个算法来管理内存，其最主要的原因是它很难解决对象之间相互循环引用的问题。**比如说对象objA和objB都有字段instance，赋值令objA.instance=objB及objB.instance=objA，除此之外，这两个对象再无任何引用，实际上两个对象已经不可能再被访问，但是因为**互相引用着对方，导致它们的引用计数都不为0**，于是无法通知GC收集器回收它们。

## 2.2 可达性分析算法

通过 GC Roots 作为起始点进行搜索，能够**到达到的对象都是存活的，不可达的对象可被回收**。

![](https://raw.githubusercontent.com/wuqifan1098/picBed/master/root-tracing.png)

GC用的引用可达性分析算法中，哪些对象可作为GC Roots对象？

- **虚拟机栈（栈帧中的本地变量表）中引用的对象。**
- 方法区中静态属性引用的对象。
- **方法区中常量引用的对象。**
- **本地方法栈中 JNI （即一般说的 Native 方法）引用的对象。**

## 2.3 引用类型

**1．强引用**

以前我们使用的大部分引用实际上都是强引用，这是使用最普遍的引用。如果一个对象具有强引用，那就类似于**必不可少的生活用品，垃圾回收器绝不会回收它**。当内存空 间不足，Java虚拟机宁愿抛出**OutOfMemoryError错误**，使程序异常终止，也不会靠随意回收具有强引用的对象来解决内存不足问题。类似“Object obj = new Object()",只要强引用还存在，垃圾收集器永远不会回收掉被引用的对象。

**2．软引用（SoftReference）**

如果一个对象只具有软引用，那就类似于可有可无的生活用品。**如果内存空间足够，垃圾回收器就不会回收它，如果内存空间不足了，就会回收这些对象的内存。**只要垃圾回收器没有回收它，该对象就可以被程序使用。软引用可用来实现内存敏感的高速缓存。

软引用可以和一个引用队列（ReferenceQueue）联合使用，如果软引用所引用的对象被垃圾回收，JAVA虚拟机就会把这个软引用加入到与之关联的引用队列中。

**3．弱引用（WeakReference）**

如果一个对象只具有弱引用，那就类似于可有可无的生活用品。弱引用与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它 所管辖的内存区域的过程中，**一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存**。不过，由于垃圾回收器是一个优先级很低的线程， 因此不一定会很快发现那些只具有弱引用的对象。

弱引用可以和一个引用队列（ReferenceQueue）联合使用，如果弱引用所引用的对象被垃圾回收，Java虚拟机就会把这个弱引用加入到与之关联的引用队列中。

**4．虚引用（PhantomReference）**

"虚引用"顾名思义，就是形同虚设，与其他几种引用都不同，虚引用并不会决定对象的生命周期。**如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收**。

## 2.4 如何判断一个常量是废弃常量

假如在常量池中存在字符串 "abc"，如果当前**没有任何String对象引用该字符串常量**的话，就说明常量 "abc" 就是废弃常量，如果这时发生内存回收的话而且有必要的话，"abc" 就会被系统清理出常量池。

## 2.5 如何判断一个类是无用的类

- 该类所有的实例都已经被回收，也就是 **Java 堆中不存在该类的任何实例**。
- **加载该类的 ClassLoader 已经被回收**。
- 该类对应的 java.lang.Class 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。

## 2.6 finalize()

finalize()是Object的protected方法，子类可以覆盖该方法以实现资源清理工作，GC在回收对象之前调用该方法。

finalize流程：当对象变成(GC Roots)不可达时，GC会判断该对象**是否覆盖了finalize方法，若未覆盖，则直接将其回收**。否则，若对象未执行过finalize方法，将其放入F-Queue队列，由一低优先级线程执行该队列中对象的finalize方法。执行finalize方法完毕后，GC会再次**判断该对象是否可达，若不可达，则进行回收，否则，对象“复活”**。

```java
import sun.misc.GC;

/**
 * @Peter start
 * @date 2019/7/17 - 15:30
 */
public class FinalizeEscapeGC {
    public static FinalizeEscapeGC SAVE_HOOK = null;
    
    @Override
    protected void finalize() throws Throwable {
        super.finalize();
        System.out.println("execute method finalize()");
        FinalizeEscapeGC.SAVE_HOOK = this;
    }

    public static void main(String[] args) throws InterruptedException {
        SAVE_HOOK = new FinalizeEscapeGC();
        SAVE_HOOK = null;
        System.gc();
        Thread.sleep(500);
        if (null != SAVE_HOOK) { //此时对象应该处于(reachable, finalized)状态
            System.out.println("Yes , I am still alive");
        } else {
            System.out.println("No , I am dead");
        }
        SAVE_HOOK = null;
        System.gc();
        Thread.sleep(500);
        if (null != SAVE_HOOK) {
            System.out.println("Yes , I am still alive");
        } else {
            System.out.println("No , I am dead");
        }

}
}
```

# 3. 垃圾收集算法

## 3.1 标记-清除算法

算法分为“标记”和“清除”阶段：**首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象**。它是最基础的收集算法，效率也很高，但是会带来两个明显的问题：

1. 效率问题
1. 空间问题（标记清除后会产生大量不连续的碎片）

![](https://raw.githubusercontent.com/wuqifan1098/picBed/master/%E6%A0%87%E8%AE%B0%E6%B8%85%E9%99%A4.jpg)

## 3.2 复制算法

为了解决效率问题，“复制”收集算法出现了。**它可以将内存分为大小相同的两块，每次使用其中的一块**。当这一块的内存使用完后，就将还存活的对象复制到另一块去，然后再把使用的空间一次清理掉。这样就使每次的内存回收都是对内存区间的一半进行回收。

![](https://raw.githubusercontent.com/wuqifan1098/picBed/master/%E5%A4%8D%E5%88%B6%E7%AE%97%E6%B3%95.jpg)

现在的商业虚拟机都采用这种收集算法来回收新生代，但是并不是将新生代划分为大小相等的两块，而是**分为一块较大的 Eden 空间和两块较小的 Survivor 空间，每次使用 Eden 空间和其中一块 Survivor。**在回收时，将 Eden 和 Survivor 中还存活着的对象一次性复制到另一块 Survivor 空间上，最后清理 Eden 和使用过的那一块 Survivor。

HotSpot 虚拟机的 Eden 和 Survivor 的**大小比例默认为 8:1**，保证了内存的利用率达到 90%。如果每次回收有多于 10% 的对象存活，那么一块 Survivor 空间就不够用了，此时需要依赖于老年代进行分配担保，也就是借用老年代的空间存储放不下的对象。

## 3.3 标记-整理算法

标记过程仍然与"标记-清除"算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清除掉端边界以外的内存。

## 3.4 分代收集

比如在新生代中，**每次收集都会有大量对象死去**，所以可以选择复制算法，只需要**付出少量对象的复制成本**就可以完成每次垃圾收集。而老年代的对象存活几率是比较高的，而且没有额外的空间对它进行分配担保，所以我们必须选择“标记-清除”或“标记-整理”算法进行垃圾收集。

- 新生代使用：复制算法
- 老年代使用：标记 - 清除 或者 标记 - 整理 算法

# 4. 垃圾收集器

![](https://raw.githubusercontent.com/wuqifan1098/picBed/master/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8.jpg)

以上是 HotSpot 虚拟机中的 7 个垃圾收集器，连线表示垃圾收集器可以配合使用。

单线程与多线程：单线程指的是垃圾收集器只使用一个线程进行收集，而多线程使用多个线程；
串行与并行：串行指的是垃圾收集器与用户程序交替执行，这意味着在执行垃圾收集的时候需要停顿用户程序；并形指的是垃圾收集器和用户程序同时执行。除了 CMS 和 G1 之外，其它垃圾收集器都是以串行的方式执行。

## 4.1 Serial收集器

Serial（串行）收集器收集器是最基本、历史最悠久的垃圾收集器了。大家看名字就知道这个收集器是一个单线程收集器了。它的 “单线程” 的意义不仅仅意味着它只会使用一条垃圾收集线程去完成垃圾收集工作，更重要的是它在进行垃圾收集工作的时候必须暂停其他所有的工作线程（ "Stop The World" ），直到它收集结束。

**新生代采用复制算法，老年代采用标记-整理算法。**

![](https://raw.githubusercontent.com/wuqifan1098/picBed/master/serial.png)

它是单线程的收集器，**只会使用一个线程进行垃圾收集工作**。

它的优点是**简单高效，对于单个 CPU 环境来说，由于没有线程交互的开销**，因此拥有最高的单线程收集效率。

## 4.2 ParNew收集器

**ParNew收集器其实就是Serial收集器的多线程版本，除了使用多线程进行垃圾收集外，其余行为（控制参数、收集算法、回收策略等等）和Serial收集器完全一样。**能与CMS收集器配合使用。

![](https://raw.githubusercontent.com/wuqifan1098/picBed/master/parNew.png)

**并行和并发概念补充：**

- 并行（Parallel） ：指多条垃圾收集线程并行工作，但此时用户线程仍然处于等待状态。

- 并发（Concurrent）：指用户线程与垃圾收集线程同时执行（但不一定是并行，可能会交替执行），用户程序在继续运行，而垃圾收集器运行在另一个CPU上。

默认开启的线程数量与 CPU 数量相同，可以使用 -XX:ParallelGCThreads 参数来设置线程数。

## 4.3 Parallel Scavenge

**与 ParNew 的不同之处：**

**Parallel Scavenge收集器关注点是吞吐量（高效率的利用CPU），尽可能缩短垃圾收集时用户线程的停顿时间，而它的目标是达到一个可控制的吞吐量，因此它被称为“吞吐量优先”收集器。CMS等垃圾收集器的关注点更多的是用户线程的停顿时间（提高用户体验）。**所谓吞吐量就是CPU中用于运行用户代码的时间与CPU总消耗时间的比值。

Parallel Scavenge 收集器提供了两个参数用于**精确控制吞吐量**

- 最大垃圾收集停顿时间： -XX:MaxGCPauseMills
- 吞吐量大小：-XX:GCTimeRatio

## 4.4 Serial Old

![](https://raw.githubusercontent.com/wuqifan1098/picBed/master/serial-old.png)

Serial收集器的老年代版本，它同样是一个单线程收集器。它主要有两大用途：一种用途是在JDK1.5以及以前的版本中与Parallel Scavenge收集器搭配使用，另一种用途是**作为CMS收集器的后备方案**。

## 4.5 Parallel Old

![](https://raw.githubusercontent.com/wuqifan1098/picBed/master/parallel-old.png)

Parallel Old 是 Parallel Scavenge 收集器的老年代版本，使用多线程和 ”标记-整理“ 算法。

在注重吞吐量以及 CPU 资源敏感的场合，都可以优先考虑 **Parallel Scavenge 加 Parallel Old 收集器。**

## 4.6 CMS

CMS（Concurrent Mark Sweep）收集器是一种以**获取最短回收停顿时间为目标的收集器**。它而非常符合在注重用户体验的应用上使用。

CMS（Concurrent Mark Sweep）收集器是HotSpot虚拟机第一款真正意义上的并发收集器，它第一次实现了让垃圾收集线程与用户线程（基本上）同时工作。

- **初始标记：** **暂停所有的其他线程**，并标记下**与root相连的对象**，速度很快 ；

- **并发标记：** **同时开启GC和用户线程**，用一个闭包结构**去记录可达对象**。但在这个阶段结束，这个闭包结构并不能保证包含当前所有的可达对象。因为用户线程可能会不断的更新引用域，所以GC线程无法保证可达性分析的实时性。所以这个算法里会跟踪记录这些发生引用更新的地方。**耗时最长，不需要停顿**。

- **重新标记：** 重新标记阶段就是为了**修正并发标记期间因为用户程序继续运行而导致标记产生变动的那一部分对象的标记记录**，这个阶段的停顿时间一般会比初始标记阶段的时间稍长，远远比并发标记阶段时间短

- **并发清除：** 开启用户线程，同时**GC线程开始对为标记的区域做清扫**。

从它的名字就可以看出它是一款优秀的垃圾收集器，主要优点：并发收集、低停顿。但是它有下面三个明显的缺点：

- 对CPU资源敏感；
- 无法处理浮动垃圾；
- 它使用的回收算法-“标记-清除”算法会导致收集结束时会有大量空间碎片产生。

## 4.7 G1收集器

G1（Garbage-First），它是一款面向服务端应用的垃圾收集器，在多 CPU 和大内存的场景下有很好的性能。HotSpot 开发团队赋予它的使命是未来**可以替换掉 CMS 收集器**。

G1 可以直接对新生代和老年代一起回收。

- **并行与并发：**G1能充分利用CPU、多核环境下的硬件优势，使用**多个CPU（CPU或者CPU核心）来缩短Stop-The-World停顿时间。**部分其他收集器原本需要停顿Java线程执行的GC动作，G1收集器仍然可以通过并发的方式让java程序继续执行。

- **分代收集：**虽然G1可以不需要其他收集器配合就能独立管理整个GC堆，但是还是保留了分代的概念。

- **空间整合：**与CMS的**“标记--清理”**算法不同，G1从整体来看是**基于“标记整理”算法**实现的收集器；从局部上来看是基于“复制”算法实现的。

- **可预测的停顿：**这是G1相对于CMS的另一个大优势，**降低停顿时间是G1 和 CMS 共同的关注点**，但G1 除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为M毫秒的时间片段内。

G1收集器的运作大致分为以下几个步骤：

- 初始标记
- 并发标记
- 最终标记
- 筛选回收

## 4.8 比较

| 收集器 | 串行、并行 or 并发 | 新生代 / 老年代 | 算法 | 目标 | 适用场景 |
| --- | --- | --- | --- | --- | --- |
| **Serial** | 串行 | 新生代 | 复制算法 | 响应速度优先 | 单 CPU 环境下的 Client 模式 |
| **Serial Old** | 串行 | 老年代 | 标记 - 整理 | 响应速度优先 | 单 CPU 环境下的 Client 模式、CMS 的后备预案 |
| **ParNew** | 并行 | 新生代 | 复制算法 | 响应速度优先 | 多 CPU 环境时在 Server 模式下与 CMS 配合 |
| **Parallel Scavenge** | 并行 | 新生代 | 复制算法 | 吞吐量优先 | 在后台运算而不需要太多交互的任务 |
| **Parallel Old** | 并行 | 老年代 | 标记 - 整理 | 吞吐量优先 | 在后台运算而不需要太多交互的任务 |
| **CMS** | 并发 | 老年代 | 标记 - 清除 | 响应速度优先 | 集中在互联网站或 B/S 系统服务端上的 Java 应用 |
| **G1** | 并发 | both | 标记 - 整理 + 复制算法 | 响应速度优先 | 面向服务端应用，将来替换 CMS |



