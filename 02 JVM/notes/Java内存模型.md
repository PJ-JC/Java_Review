# 面试题

## 1. Java内存模型是什么

JMM(Java Memory Model) 是线程间通信的机制 。线程间共享变量存储在主内存，每个线程都有自己的本地内存，存储的是共享变量在本地的副本。

可以把内存模型理解为**在特定操作协议下，对特定的内存或高速缓存进行读写访问的过程抽象**。

不同架构的物理计算机可以有不一样的内存模型，Java虚拟机也有自己的内存模型。Java虚拟机规范中试图定义一种Java内存模型（Java Memory Model，简称JMM）来**屏蔽掉各种硬件和操作系统的内存访问差异**，以实现**让Java程序在各种平台下都能达到一致的内存访问效果**，不必因为不同平台上的物理机的内存模型的差异，对各平台定制化开发程序。

更具体一点说，Java内存模型提出目标在于，**定义程序中各个变量的访问规则，即在虚拟机中将变量存储到内存和从内存中取出变量这样的底层细节**。此处的变量(Variables)与Java编程中所说的变量有所区别，它包括了实例字段、静态字段和构成数值对象的元素，但不包括局部变量与方法参数，因为后者是线程私有的。(如果局部变量是一个reference类型，它引用的对象在Java堆中可被各个线程共享，但是reference本身在Java栈的局部变量表中，它是线程私有的)。


作者：贝聊科技链接：https://juejin.im/post/5bf2977751882505d840321d

# 一、Java 内存模型的主要目标

Java 内存模型的主要目标是 定义程序中各个变量的访问规则，即在虚拟机中 将变量存储到内存 和 从内存中取出变量 这样的底层细节。

# 二、主内存与工作内存

Java 内存模型规定了所有的变量都存储在主内存（Main Memory， 这里指的是虚拟机内存的一部分）中。每条线程还有自己的工作内存（Working Memory，可以与处理器高速缓存类比），线程的工作内存中保存了被该线程使用到的变量的主内存副本拷贝，线程对变量的所有操作（读取、赋值等）都必须在工作内存中进行，而不能直接读写主内存中的变量。

不同的线程之间也无法直接访问对方工作内存中的变量，线程间变量值的传递均需要通过主内存来完成，线程、主内存、工作内存三者的交互关系如下图所示。

![线程、主内存、工作内存](E:\面试\Java复习\02 JVM\pics\线程、主内存、工作内存.webp)

这里说的主内存、工作内存和 Java 内存区域中的 Java 堆、栈、方法区等并不是同一个层次的内存划分，这两者基本是没有关系的，如果两者一定要勉强对应起来的话，那从变量、主内存、工作内存的定义来看，**主内存主要对应于 Java 堆中的对象实例数据部分**，而**工作内存则对应于 Java 虚拟机栈中的部分区域。**

操作变量时的规则：

- Java内存模型规定了所有的**变量都存储在主内存**
- 线程的**工作内存**中保存了被该线程使用到的变量的主内存**副本拷贝**
- 线程对变量的所有**操作**（读取、赋值等）都必须在**工作内存中进行**，而不能直接读写主内存中的变量

# 三、内存件交互操作

从**工作内存同步回主内存**实现是通过以下的8种操作来完成：

- lock（锁定）：作用于主内存的变量，它把一个变量标识为一条线程独占的状态。

- unlock（解锁）：作用于主内存的变量，它把一个处于锁定状态的变量释放出来，释放后变量才可以被其他线程锁定。

- read（读取）：作用于主内存的变量，它把一个变量的值从主内存传输到工作内存中，以便随后的 load 动作使用。

- load（载入）：作用于工作内存的变量，它把 read 操作从主内存得到的变量值保存到工作内存的变量副本中。

- use（使用）：作用于工作内存的变量，它把工作内存中的一个变量的值传递给执行引擎（一般是基于操作数栈的执行引擎），每当虚拟机遇到一个需要使用到该变量的值的  字节码指令时将会执行这个操作。

- assign（赋值）：作用于工作内存的变量，它把从执行引擎接收到的值赋值给工作内存的变量（存放在局部变量表中），每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作。

- store（存储）：作用于工作内存的变量，它把工作内存中的变量传送到主内存中，以便随后的 write 操作使用。

- write（写入）：作用于主内存的变量，它把 store 操作从工作内存中得到的变量的值方法主内存的变量中。

# 四、原子性、可见性与有序性

- **原子性（Atomicity）** 也就是说 Java 内存模型中的 read、load、use、assign、store 和 wriet 这 6 种操作可以保证 基本数据类型 的原子性，而 Java 内存模型定义的 lock 和 unlock 操作则可以保证 基本数据类型 以外的数据类型的原子性。

- **可见性（Visibility）：** 可见性是指一个线程修改了一个变量的值，其他线程可以立即得知这个修改。可以说 volatile 保证了多线程操作时变量的可见性，而普通变量则不能保证这一点。除了 volatile 之外，Java 还有两个关键字能实现可见性，即 synchronized 和 final。

- **有序性（Ordering）**：Java 语言**提供了 volatile 和 synchronized 两个关键字来保证线程之间操作的有序性**，volatile 关键字本身就包含了进制指令重排序的语义，而 synchronized 则是由“一个变量在同一个时刻只允许一条线程对其进行 lock 操作”这条规则获得的，这条规则决定了持有同一个锁的两个同步块只能串行的进入

# 五、happens-before原则

　  a.程序次序规则(Pragram Order Rule)：在一个线程内，按照程序代码顺序，书写在前面的操作先行发生于书写在后面的操作。准确地说应该是控制流顺序而不是程序代码顺序，因为要考虑分支、循环结构。

　　b.管程锁定规则(Monitor Lock Rule)：一个unlock操作先行发生于后面对同一个锁的lock操作。这里必须强调的是同一个锁，而”后面“是指时间上的先后顺序。

　　c.volatile变量规则(Volatile Variable Rule)：对一个volatile变量的写操作先行发生于后面对这个变量的读取操作，这里的”后面“同样指时间上的先后顺序。

　　d.线程启动规则(Thread Start Rule)：Thread对象的start()方法先行发生于此线程的每一个动作。

　　e.线程终于规则(Thread Termination Rule)：线程中的所有操作都先行发生于对此线程的终止检测，我们可以通过Thread.join()方法结束，Thread.isAlive()的返回值等作段检测到线程已经终止执行。

　　f.线程中断规则(Thread Interruption Rule)：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生，可以通过Thread.interrupted()方法检测是否有中断发生。

　　g.对象终结规则(Finalizer Rule)：一个对象初始化完成(构造方法执行完成)先行发生于它的finalize()方法的开始。

　　g.传递性(Transitivity)：如果操作A先行发生于操作B，操作B先行发生于操作C，那就可以得出操作A先行发生于操作C的结论。