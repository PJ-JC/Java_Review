# **什么是主从复制**

![img](https://pic1.zhimg.com/80/v2-84fff5a4c0045701f761fd4c66669a64_hd.jpg)

主从复制，是指将一台Redis服务器的数据，复制到其他的Redis服务器。前者称为主节点(master)，后者称为从节点(slave),数据的复制是单向的，只能由主节点到从节点。

默认情况下，每台Redis服务器都是主节点；且一个主节点可以有多个从节点(或没有从节点)，但一个从节点只能有一个主节点。

## 作用

1. 数据冗余：主从复制实现了数据的热备份，是持久化之外的一种数据冗余方式。
2. 故障恢复：当主节点出现问题时，可以由从节点提供服务，实现快速的故障恢复；实际上是一种服务的冗余。
3. 负载均衡：在主从复制的基础上，配合读写分离，可以由主节点提供写服务，由从节点提供读服务（即写Redis数据时应用连接主节点，读Redis数据时应用连接从节点），分担服务器负载；尤其是在写少读多的场景下，通过多个从节点分担读负载，可以大大提高Redis服务器的并发量。
4. 读写分离：可以用于实现读写分离，主库写、从库读，读写分离不仅可以提高服务器的负载能力，同时可根据需求的变化，改变从库的数量；
5. 高可用基石：除了上述作用以外，主从复制还是哨兵和集群能够实施的基础，因此说主从复制是Redis高可用的基础。

## **主从复制启用**

从节点开启主从复制，有3种方式：

1. 配置文件： 在从服务器的配置文件中加入：slaveof

2. 启动命令： redis-server启动命令后加入 --slaveof

3. 客户端命令： Redis服务器启动后，直接通过客户端执行命令：slaveof 

   ，则该Redis实例成为从节点。

> 通过 info replication 命令可以看到复制的一些信息

参考：

https://zhuanlan.zhihu.com/p/67752953

# 复制原理

主从复制过程大体可以分为3个阶段：连接建立阶段（即准备阶段）、数据同步阶段、命令传播阶段。

复制的过程步骤如下：

1. 从节点**执行 slaveof 命令**
2. 从节点只是**保存了 slaveof 命令中主节点的信息**，并没有立即发起复制
3. 从节点内部的定时任务发现有主节点的信息，开始**使用 socket 连接主节点**

- 检测主从之间**网络套接字是否可用。**
- 检测**主节点当前是否可接受处理命令**

1. 连接建立成功后，发送 ping 命令，希望得到 pong 命令响应，否则会进行重连
2. 如果主节点设置了权限，那么就需要进行**权限验证**；如果验证失败，复制终止。
3. 权限验证通过后，进行数据同步，**这是耗时最长的操作**，主节点将把所有的数据全部发送给从节点。
4. 当主节点把当前的数据同步给从节点后，便完成了复制的建立流程。接下来，**主节点就会持续的把写命令发送给从节点，保证主从数据一致性**。

![](https://raw.githubusercontent.com/wuqifan1098/picBed/master/Redis%20master%20slave.jpg)

## **数据间的同步**

redis 同步有 2 个命令：sync 和 psync，前者是 redis 2.8 之前的同步命令，后者是 redis 2.8 为了优化 sync 新设计的命令。我们会重点关注 2.8 的 psync 命令。

**psync 命令需要 3 个组件支持：**

- runID：服务器运行的 ID。

> 每个 redis 启动的时候，都会生成一个 40 位的运行 ID。
>
> 运行 ID 的主要作用是**用来识别 Redis 节点**。如果使用 ip+port 的方式，那么如果主节点重启修改
> 了 RDB/AOF 数据，从节点再基于偏移量进行复制将是不安全的。所以，当运行 id 变化后，从节点将
> 进行全量复制。也就是说，**redis 重启后，默认从节点会进行全量复制。**
>
> 如果在重启时不改变运行 ID 呢？
> 可以通过 debug reload 命令重新加载 RDB 并保持运行 ID 不变。从而有效的避免不必要的全量复制。
> 他的缺点则是：debug reload 命令会阻塞当前 Redis 节点主线程，因此对于大数据量的主节点或者
> 无法容忍阻塞的节点，需要谨慎使用。
>
> 一般通过故障转移机制可以解决这个问题。

- Offset：主服务器的**复制偏移量**和从服务器**复制的偏移量**。

> 参与复制的主从节点都会维护自身的复制偏移量。
>
> 主节点在处理完写入命令后，会把命令的字节长度做累加记录，统计信息在 **info replication** 
> 中的 master_repl_offset 指标中。
>
> 从节点每秒钟上报自身的的复制偏移量给主节点，因此主节点也会保存从节点的复制偏移量。
>
> 从节点在接收到主节点发送的命令后，也会累加自身的偏移量，统计信息在 **info replication** 中。
>
> 通过**对比主从节点的复制偏移量，可以判断主从节点数据是否一致。**

- Replication backlog：主服务器的**复制积压缓冲区**。

> 复制积压缓冲区是一个保存**在主节点的一个固定长度的先进先出的队列**。默认大小 1MB。
>
> 这个队列在 slave 连接是创建。这时主节点响应写命令时，不但会把命令发送给从节点，也会写入复制缓冲区。
>
> 他的作用就是**用于部分复制和复制命令丢失的数据补救**。
>
> 通过 info replication 可以看到相关信息。

**psync 命令的使用方式**

```text
命令格式为 `psync {runId} {offset}`

runId : 从节点所复制主节点的运行 id
offset：当前从节点已复制的数据偏移量
```

**psync 执行流程：**

![](https://raw.githubusercontent.com/wuqifan1098/picBed/master/psync%20process.jpg)

**流程说明：**从节点发送 psync 命令给主节点，runId 就是目标主节点的 ID，如果没有默认为 -1，offset 是从节点保存的复制偏移量，如果是第一次复制则为 -1.

主节点会**根据 runid 和 offset 决定返回结果：**

- 如果回复 +FULLRESYNC {runId} {offset} ，那么从节点将触发全量复制流程。
- 如果回复 +CONTINUE，从节点将触发部分复制。
- 如果回复 +ERR，说明主节点不支持 2.8 的 psync 命令，将使用 sync 执行全量复制。

Psync 命令具有**完整重同步和部分重同步**两种模式：

- 完整同步用于处理初次复制情况：

  完整重同步的执行步骤和 Sync 命令执行步骤一致，都是通过让**主服务器创建并发送 RDB 文件，以及向从服务器发送保存在缓冲区的写命令来进行同步。**

- 部分重同步是用于处理断线后重复制情况：

  当**从服务器在断线后重新连接主服务器时**，主服务可以将主从服务器连接断开期间执行的写命令发送给从服务器，从服务器**只要接收并执行这些写命令**，就可以将数据库更新至主服务器当前所处的状态。

### 完整重同步

![](https://raw.githubusercontent.com/wuqifan1098/picBed/master/Redis%E5%AE%8C%E6%95%B4%E5%90%8C%E6%AD%A5.jpg)

- **Slave 发送 Psync 给 Master**，由于是第一次发送，不带上 runID 和 Offset。
- Master 接收到请求，**发送 Master 的 runID 和 Offse**t 给从节点。
- Master  bgsave并保存 RDB 文件到本地。
- Master **发送 RDB 文件**给 Slave。
- 在发送 RDB 这个操作的同时，将**新数据复制保存到缓冲区 Replication Backlog Buffer 中**，当从节点加载RDB完毕后，再从 Buffer 区发送到 Slave。
- Slave **将 RDB 文件的数据装载，并更新自身数据**。
- **从节点清空数据后加载 RDB 文件，如果 RDB 文件很大，这一步操作仍然耗时，如果此时客户端访问，将导致数据不一致，可以使用配置slave-server-stale-data 关闭**.
- **从节点成功加载完 RBD 后，如果开启了 AOF，会立刻做 bgrewriteaof**。

**注意：**

1. 主节点保存RDB文件，发送RDB到从节点，从节点加载RDB到内存中是最耗时的地方
2. 如过 RDB 文件大于 6GB，并且是千兆网卡，Redis 的默认超时机制（60 秒），会导致全量复制失败。**可以通过调大 repl-timeout 参数来解决此问题**。
3. Redis 虽然支持无盘复制，即直接通过网络发送给从节点，但功能不是很完善，生产环境慎用。

### 部分重同步

当从节点正在复制主节点时，如果出现网络闪断和其他异常，从节点会让主节点补发丢失的命令数据，主节点只需要将复制缓冲区的数据发送到从节点就能够保证数据的一致性，相比较全量复制，成本小很多。

![](https://raw.githubusercontent.com/wuqifan1098/picBed/master/Redis%E9%83%A8%E5%88%86%E9%87%8D%E5%90%8C%E6%AD%A5.jpg)

- 网络发生错误，Master 和 Slave 失去连接。
- Master 依然**向 Buffer 缓冲区写入数据。**
- Slave 重新连接上 Master。
- Slave 向 Master **发送主节点的 runID 和 Offset。**
- Master 会**判断 Slave 发送给自己的 Offset 是否存在 Buffer 队列中。**
- 如果存在，则发送 Continue 给 Slave;如果不存在，意味着可能错误了太多的数据，缓冲区已经被清空，这个时候就需要重新进行全量的复制。
- Master 发送**从 Offset 偏移后的缓冲区数据给 Slave。**
- Slave 获取数据更新自身数据。

## **心跳**

主从节点在建立复制后，他们之间维护着长连接并彼此发送心跳命令。

**心跳的关键机制如下：**

1. 主从都有心跳检测机制，各自模拟成对方的客户端进行通信，通过 client list 命令查看复制相关客户端信息，主节点的连接状态为 flags = M，从节点的连接状态是 flags = S。
2. 主节点默认每隔 10 秒对从节点发送 ping 命令，可修改配置 repl-ping-slave-period 控制发送频率。
3. 从节点在主线程每隔一秒发送 replconf ack{offset} 命令，给主节点上报自身当前的复制偏移量。
4. 主节点收到 replconf 信息后，判断从节点超时时间，如果超过 repl-timeout 60 秒，则判断节点下线。

![img](https://pic2.zhimg.com/80/v2-cb9a65fa5ed06030bb13eb6c553b1c51_hd.jpg)

**注意：**为了降低主从延迟，一般把 redis 主从节点部署在相同的机房/同城机房，避免网络延迟带来的网络分区造成的心跳中断等情况。

## **异步复制**

主节点不但负责数据读写，还负责把写命令同步给从节点，写命令的发送过程是异步完成，也就是说主节点处理完写命令后立即返回客户度，并不等待从节点复制完成。

**异步复制的步骤很简单，如下：**

1. 主节点接受处理命令
2. 主节点处理完后返回响应结果
3. 对于修改命令，异步发送给从节点，从节点在主线程中执行复制的命令。

![img](https://pic4.zhimg.com/80/v2-4648bfb14f4019ed3cf2876db333cf4b_hd.jpg)

# 总结

本文主要分析了 Redis 的复制原理，包括复制过程，数据之间的同步，全量复制的流程，部分复制的流程，心跳设计，异步复制流程。

其中，可以看出，**RDB 数据之间的同步非常耗时**。所以，Redis 在 2.8 版本退出了类似增量复制的 psync 命令，当 Redis 主从直接发生了网络中断，不会进行全量复制，而是**将数据放到缓冲区（默认 1MB）里，在通过主从之间各自维护复制 offset 来判断缓存区的数据是否溢出，如果没有溢出，只需要发送缓冲区数据即可，成本很小，反之，则要进行全量复制，因此，控制缓冲区大小非常的重要。**

参考

https://zhuanlan.zhihu.com/p/60239657