# redis 过期策略

redis 过期策略是：**定期删除+惰性删除**。

- **定期删除：**指的是 redis 默认是每隔 100ms 就**随机抽取**一些设置了过期时间的 key，检查其是否过期，如果过期就删除。

- **惰性删除：**在你获取某个 key 的时候，redis 会检查一下 ，这个 key 如果设置了过期时间那么是否过期了？如果过期了此时就会删除，不会给你返回任何东西。

#  redis 内存淘汰机制

redis提供了6种数据淘汰策略：

- noeviction: 当内存不足以容纳新写入数据时，新写入操作会报错，这个一般没人用吧，实在是太恶心了。
- allkeys-lru：当内存不足以容纳新写入数据时，**在键空间中，移除最近最少使用的 key**（这个是最常用的）。
- allkeys-random：当内存不足以容纳新写入数据时，**在键空间中，随机移除某个 key**，这个一般没人用吧，为啥要随机，肯定是把最近最少使用的 key 给干掉啊。
- volatile-lru：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，移除最近最少使用的 key（这个一般不太合适）。
- volatile-random：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，随机移除某个 key。
- volatile-ttl：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，有更早过期时间的 key 优先移除。

# 手写一个LRU算法

利用LinkedHashMap实现
linkedHashMap还可以实现按照访问顺序保存元素。

```java
public class UseLinkedHashMapCache<k,v> extends LinkedHashMap<k,v>{

	private int cacheSize;
	public UseLinkedHashMapCache(int cacheSize){
	//构造函数一定要放在第一行
     super(16,0.75f,true); //那个f如果不加  就是double类型，然后该构造没有该类型的入参。 然后最为关键的就是那个入参 true
	this.cacheSize = cacheSize;
	}

@Override
protected boolean removeEldestEntry(Map.Entry<k,v> eldest)}  //重写LinkedHashMap原方法
	return size() > cacheSize; //临界条件不能有等于，否则会让缓存尺寸小1
}
```

关键点:

继承了LinkedHashMap并使用

```java
public LinkedHashMap(int initialCapacity,
                     float loadFactor,
                     boolean accessOrder) {
    super(initialCapacity, loadFactor);
    this.accessOrder = accessOrder;
}
```

构造函数

重写了

```java
protected boolean removeEldestEntry(Map.Entry<K,V> eldest) {
    return false;
}
```

