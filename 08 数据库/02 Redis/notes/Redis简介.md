# 面试题

## Redis 的哪种数据类型用到了跳表结构？

跳跃表是有序集合的底层实现之一

## 为什么要用Redis

**高性能：**

假如用户第一次访问数据库中的某些数据。这个过程会比较慢，因为是从硬盘上读取的。将该用户访问的**数据存在数缓存中，这样下一次再访问这些数据的时候就可以直接从缓存中获取了**。操作缓存就是直接操作内存，所以速度相当快。如果数据库中的对应数据改变的之后，同步改变缓存中相应的数据即可！

**高并发：**

直接操作缓存能够承受的请求是远远大于直接访问数据库的，所以我们**可以考虑把数据库中的部分数据转移到缓存中去，这样用户的一部分请求会直接到缓存这里而不用经过数据库**。

## Redis为什么设计成单线程

redis 核心就是 如果我的数据全都在内存里，我单线程的去操作就是效率最高的，为什么呢，因为多线程的本质就是 CPU 模拟出来多个线程的情况，这种模拟出来的情况就有一个代价，就是**上下文的切换**，对于一个内存的系统来说，它没有上下文的切换就是效率最高的。redis **用 单个CPU 绑定一块内存的数据，然后针对这块内存的数据进行多次读写的时候，都是在一个CPU上完成的**，所以它是单线程处理这个事。

单进程单线程弊端
无法发挥多核CPU性能，不过可以通过在**单机开多个Redis实例**来完善；

1. redis是**基于内存的**，内存的读写速度非常快；
1. redis是单线程的，**省去了很多上下文切换线程的时间**，不用考虑锁
1. redis使**用多路复用技术**，可以处理并发的连接；

重点解释下多路复用：
多路-指的是多个socket连接，复用-指的是复用一个线程。
目前，多路复用主要有三种技术：**select，poll，epoll。**
它们出现的顺序是的，越排后的技术改正了之前技术的缺点。epoll是最新的也是目前最好的多路复用技术。
举个例子：一个酒吧服务员，前面有很多醉汉，epoll这种方式相当于一个醉汉吼了一声要酒，服务员听见之后就去给他倒酒，而在这些醉汉没有要求的时候可以玩玩手机等。但是select和poll技术是这样的场景：服务员轮流着问各个醉汉要不要倒酒，没有空闲的时间。io多路复用的意思就是做个醉汉公用一个服务员。

# 常见数据类型及应用场景

**1.String**

常用命令: set,get,decr,incr,mget 等。

String数据结构是简单的key-value类型，value其实不仅可以是String，也可以是数字。 常规key-value缓存应用； 常规计数：**微博数，粉丝数等**。

**2.Hash**

常用命令： hget,hset,hgetall 等。

hash 是一个 string 类型的 field 和 value 的映射表，hash 特别适合用于存储对象，后续操作的时候，你可以直接仅仅修改这个对象中的某个字段的值。 **比如我们可以 hash 数据结构来存储用户信息，商品信息等等**。比如下面我就用 hash 类型存放了我本人的一些信息：

key=JavaUser293847
value={
  “id”: 1,
  “name”: “SnailClimb”,
  “age”: 22,
  “location”: “Wuhan, Hubei”
}

**3.List**

常用命令: lpush,rpush,lpop,rpop,lrange等

list 就是链表，Redis list 的应用场景非常多，也是Redis最重要的数据结构之一，比如微博的**关注列表，粉丝列表，消息列表**等功能都可以用Redis的 list 结构来实现。

Redis list 的实现为一个双向链表，即可以支持反向查找和遍历，更方便操作，不过带来了部分额外的内存开销。

另外可以通过 lrange 命令，就是从某个元素开始读取多少个元素，可以基于 list 实现分页查询，这个很棒的一个功能，基于 redis 实现简单的高性能分页，可以做类似微博那种下拉不断分页的东西（一页一页的往下走），性能高。

**4.Set**

常用命令： sadd,spop,smembers,sunion 等

set 对外提供的功能与list类似是一个列表的功能，特殊之处在于 set 是可以自动排重的。

当你需要**存储一个列表数据，又不希望出现重复数据时**，set是一个很好的选择，并且set提供了判断某个成员是否在一个set集合内的重要接口，这个也是list所不能提供的。可以基于 set 轻易实现交集、并集、差集的操作。

比如：在微博应用中，可以将一个用户所有的关注人存在一个集合中，将其所有粉丝存在一个集合。**Redis可以非常方便的实现如共同关注、共同粉丝、共同喜好等功能**。这个过程也就是求交集的过程，具体命令如下：

sinterstore key1 key2 key3     将交集存在key1内

**5.Sorted Set**

常用命令： zadd,zrange,zrem,zcard等

和set相比，sorted set增加了一个权重参数score，使得集合中的元素能够按score进行有序排列。

举例： 在直播系统中，**实时排行信息包含直播间在线用户列表**，各种礼物排行榜，弹幕消息（可以理解为按消息维度的消息排行榜）等信息，适合使用 Redis 中的 Sorted Set 结构进行存储。

# redis 内存淘汰机制(MySQL里有2000w数据，Redis中只存20w的数据，如何保证Redis中的数据都是热点数据?)

redis 配置文件 redis.conf 中有相关注释，我这里就不贴了，大家可以自行查阅或者通过这个网址查看： http://download.redis.io/redis-stable/redis.conf

redis 提供 6种数据淘汰策略：

1. volatile-lru：从已设置过期时间的数据集（server.db[i].expires）中挑选最近最少使用的数据淘汰
1. volatile-ttl：从已设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数据淘汰
1. volatile-random：从已设置过期时间的数据集（server.db[i].expires）中任意选择数据淘汰
1. allkeys-lru：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的key（这个是最常用的）
1. allkeys-random：从数据集（server.db[i].dict）中任意选择数据淘汰
1. no-eviction：禁止驱逐数据，也就是说当内存不足以容纳新写入数据时，新写入操作会报错。这个应该没人使用吧！

