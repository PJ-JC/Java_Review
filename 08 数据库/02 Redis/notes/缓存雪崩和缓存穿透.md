# 面试题

## 1.缓存穿透

缓存穿透是**指查询一个一定不存在的数据，因为缓存中也无该数据的信息，则会直接去数据库层进行查询**，从系统层面来看像是穿透了缓存层直接达到db，从而称为缓存穿透，没有了缓存层的保护，这种查询一定不存在的数据对系统来说可能是一种危险，如果有人恶意用这种一定不存在的数据来频繁请求系统，不，准确的说是攻击系统，请求都会到达数据库层导致db瘫痪从而引起系统故障。

### 解决方案

缓存穿透业内的解决方案已经比较成熟，主要常用的有以下几种：

bloom filter：类似于哈希表的一种算法，**用所有可能的查询条件生成一个bitmap，在进行数据库查询之前会使用这个bitmap进行过滤，如果不在其中则直接过滤，从而减轻数据库层面的压力。guava中有实现BloomFilter算法**

空值缓存：一种比较简单的解决办法，在第一次查询完不存在的数据后，将该key与对应的空值也放入缓存中，只不过设定为较短的失效时间，例如几分钟，这样则可以应对短时间的大量的该key攻击，设置为较短的失效时间是因为该值可能业务无关，存在意义不大，且该次的查询也未必是攻击者发起，无过久存储的必要，故可以早点失效。

### 缓存雪崩

在普通的缓存系统中一般例如redis、memcache等中，我们会给缓存设置一个失效时间，但是如果**所有的缓存的失效时间相同，那么在同一时间失效时，所有系统的请求都会发送到数据库层，db可能无法承受如此大的压力导致系统崩溃。**

### 解决方案

线程互斥：**只让一个线程构建缓存，其他线程等待构建缓存的线程执行完，重新从缓存获取数据才可以**，每个时刻只有一个线程在执行请求，减轻了db的压力，但缺点也很明显，降低了系统的qps。

**交错失效时间**：这种方法时间比较简单粗暴，既然在同一时间失效会造成请求过多雪崩，那我们错开不同的失效时间即可从一定长度上避免这种问题，在缓存进行失效时间设置的时候，从某个适当的值域中随机一个时间作为失效时间即可。

### 缓存击穿

缓存击穿实际上是缓存雪崩的一个特例，大家使用过微博的应该都知道，微博有一个热门话题的功能，用户对于热门话题的搜索量往往在一些时刻会大大的高于其他话题，这种我们成为系统的“热点“，由于系统中对这些热点的数据缓存也存在失效时间，在热点的缓存到达失效时间时，此时可能依然会有大量的请求到达系统，没有了缓存层的保护，这些请求同样的会到达db从而可能引起故障。**击穿与雪崩的区别即在于击穿是对于特定的热点数据来说，而雪崩是全部数据。**

### 解决方案

二级缓存：**对于热点数据进行二级缓存，并对于不同级别的缓存设定不同的失效时间，则请求不会直接击穿缓存层到达数据库。** 

这里参考了阿里双11万亿流量的缓存击穿解决方案，解决此问题的关键在于热点访问。由于热点可能随着时间的变化而变化，针对固定的数据进行特殊缓存是不能起到治本作用的，结合LRU算法能够较好的帮我们解决这个问题。

https://cloud.tencent.com/developer/article/1422153

# 缓存雪崩

简介：**缓存同一时间大面积的失效，所以，后面的请求都会落到数据库上，造成数据库短时间内承受大量请求而崩掉。**

解决办法（中华石杉老师在他的视频中提到过，视频地址在最后一个问题中有提到）：

事前：尽量保证整个 **redis 集群的高可用性**，发现机器宕机尽快补上。选择**合适的内存淘汰策略**。

事中：**本地ehcache缓存 + hystrix限流&降级**，避免MySQL崩掉

事后：利用 redis **持久化机制**保存的数据尽快恢复缓存

# 缓存穿透

简介：一般是黑客故意去**请求缓存中不存在的数据，导致所有的请求都落到数据库上**，造成数据库短时间内承受大量请求而崩掉。

![](https://raw.githubusercontent.com/wuqifan1098/picBed/master/20190529205729.png)

解决缓存穿透也有两种方案：

- 由于请求的参数是不合法的(每次都请求不存在的参数)，于是我们可以使用布隆过滤器(BloomFilter)或者压缩filter**提前拦截**，不合法就不让这个请求到数据库层！

- 当我们从数据库找不到的时候，我们也将这个**空对象设置到缓存里边去**。下次再请求的时候，就可以从缓存里边获取了。

- 这种情况我们一般会将空对象设置一个**较短的过期时间**。

