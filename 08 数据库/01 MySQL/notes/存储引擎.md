# 面试题

## 1.MySQL InnoDB存储引擎中的MVCC解决了什么问题，能说下MVCC的实现原理么（vivo）

获得高并发性，通过对普通的SELECT不加锁，直接利用MVCC读取指版本的值，避免了对数据重复加锁的过程。

好处： 读不加锁，读写不冲突。

它**存储了每一行的两个(1)额外的隐藏字段，这两个隐藏字段分别记录了行的创建的时间和删除的时间。**在每个事件发生的时候，每行存储版本号，而不是存储事件实际发生的时间。每次事物的开始这个版本号都会增加。自记录时间开始，每个事物都会保存记录的系统版本号。依照事物的 版本来检查每行的版本号。在事物隔离级别为可重复读的情况下，来看看怎样应用它。

https://www.cnblogs.com/phpper/p/6937650.html

## 2. MyISAM和InnoDB的区别

作者：Oscarwin

**区别：**

- InnoDB**支持事务，MyISAM不支持**，对于InnoDB每一条SQL语言都默认封装成事务，自动提交，这样会影响速度，所以最好把多条SQL语言放在begin和commit之间，组成一个事务；  

- InnoDB**支持外键**，而MyISAM不支持。对一个包含外键的InnoDB表转为MYISAM会失败；  

-  InnoDB是**聚集索引**，数据文件是和索引绑在一起的，必须要有主键，通过主键索引效率很高。但是辅助索引需要两次查询，先查询到主键，然后再通过主键查询到数据。因此，主键不应该过大，因为主键太大，其他索引也都会很大。而MyISAM是**非聚集索引，数据文件是分离的，索引保存的是数据文件的指针**。主键索引和辅助索引是独立的。 

- InnoDB**不保存表的具体行数**，执行select count(*) from table时需要全表扫描。而MyISAM用一个变量保存了整个表的行数，执行上述语句时只需要读出该变量即可，速度很快；  

- Innodb不支持全文索引，而MyISAM支持全文索引，查询效率上MyISAM要高；   
- InnoDB支持表锁，行锁；MyISAM支持表锁，但是InnoDB的行锁，只是在WHERE的主键是有效的，非主键的WHERE都会锁全表的

**如何选择：**

-  是否要支持事务，如果要请选择innodb，如果不需要可以考虑MyISAM；
-  如果表中绝大多数都只是**读查询**，可以考虑MyISAM，如果**既有读写也挺频繁**，请使用InnoDB。
-  系统奔溃后，MyISAM**恢复起来更困难**，能否接受；
-   MySQL5.5版本开始Innodb已经成为Mysql的默认引擎(之前是MyISAM)，说明其优势是有目共睹的，如果你不知道用什么，那就用InnoDB，至少不会差。

## 3. InnoDB里实现了哪几种锁？（作业帮）

共享锁：允许事务读一行数据

排他锁：允许事务删除或更新一行数据

意向共享锁、意向排他锁

记录锁

间隙锁

next-key临键锁

自增锁

https://www.jianshu.com/p/8c0c9d3b0306

## 4. InnoDB的redo log和MySQL的binlog有什么异同？



## 5. 为什么要建议用自增列做主键

如果表使用自增主键，那么每次插入新的记录，记录就会顺序添加到当前索引节点的后续位置，当一页写满，就会自动开辟一个新的页。

使用自增列(INT/BIGINT类型)做主键，这时候写入顺序是自增的，和B+数叶子节点分裂顺序一致，存取效率是最高的

# MySQL各大存储引擎

- InnoDB 
- MyIsam 
- Memory（也叫HEAP）
- Mrg_Myisam：（分表的一种方式–水平分表）
- Blackhole（黑洞引擎）

## InnoDB

InnoDB是一个事务型的存储引擎，有行级锁定和外键约束。

### 适用场景：

1）经常更新的表，适合处理多重并发的更新请求。
2）支持事务。
3）可以从灾难中恢复（通过bin-log日志等）。
4）外键约束。只有他支持外键。
5）支持自动增加列属性auto_increment。

## MYIsaM

MyIASM是MySQL默认的引擎，但是它**没有提供对数据库事务的支持，也不支持行级锁和外键**，因此当INSERT(插入)或UPDATE(更新)数据时即写操作需要锁定整个表，效率便会低一些。

### 适用场景：

1）不支持事务的设计，但是并不代表着有事务操作的项目不能用MyIsam存储引擎，可以在service层进行根据自己的业务需求进行相应的控制。
2）不支持外键的表设计。
3）查询速度很快，如果数据库insert和update的操作比较多的话比较适用。
4）整天 对表进行加锁的场景。
5）MyISAM极度强调快速读取操作。
6）MyIASM中存储了表的行数，于是SELECT COUNT(*) FROM TABLE时只需要直接读取已经保存好的值而不需要进行全表扫描。如果表的读操作远远多于写操作且不需要数据库事务的支持，那么MyIASM也是很好的选择。

# InnoDB和MyIsam使用及其原理对比

1）事务。MyISAM类型**不支持事务处理等高级处理**，而InnoDB类型**支持，提供事务支持**已经外部键等高级数据库功能。

2）性能主题。MyISAM类型的表**强调的是性能**，其执行数度比InnoDB类型更快。

3）行数保存。InnoDB 中不保存表的具体行数，也就是说，执行select count() fromtable时，InnoDB要扫描一遍整个表来计算有多少行，但是MyISAM只要简单的读出保存好的行数即可。注意的是，当count()语句包含where条件时，两种表的操作是一样的。

4）索引存储。对于AUTO_INCREMENT类型的字段，InnoDB中必须包含只有该字段的索引，但是在MyISAM表中，可以和其他字段一起建立联合索引。

5）服务器数据备份。InnoDB必须导出SQL来备份，LOAD TABLE FROM MASTER操作对InnoDB是不起作用的，解决方法是首先把InnoDB表改成MyISAM表，导入数据后再改成InnoDB表，但是对于使用的额外的InnoDB特性(例如外键)的表不适用。
而且MyISAM应对错误编码导致的数据恢复速度快。MyISAM的数据是以文件的形式存储，所以在跨平台的数据转移中会很方便。在备份和恢复时可单独针对某个表进行操作。

6）锁的支持。MyISAM只支持**表锁**。InnoDB**支持表锁、行锁** 行锁大幅度提高了多用户并发操作的新能。但是InnoDB的行锁，只是在WHERE的主键是有效的，非主键的WHERE都会锁全表的

## 使用场景

以下两点必须使用 InnoDB：
1）**可靠性高或者要求事务处理**，则使用InnoDB。这个是必须的。
2）**表更新和查询都相当的频繁**，并且表锁定的机会比较大的情况指定InnoDB数据引擎的创建。

对比之下，MyISAM的使用场景：
1）做**很多count的计算的**。如一些日志，调查的业务表。
2）**插入修改不频繁**，**查询非常频繁的**。

## InnoDB和MyIsam引擎原理：

（1）MyIASM引擎的索引结构：

MyISAM索引结构: MyISAM索引用的**B+ tree来储存数据**，MyISAM索引的指针指向的是**键值的地址，地址存储的是数据。**

B+Tree的数据域存储的内容为实际数据的地址，也就是说它的索引和实际的数据是分开的，只不过是用索引指向了实际的数据，**这种索引就是所谓的非聚集索引**。

（2）InnoDB引擎的索引结构：

也是B+Tree索引结构。Innodb的**索引文件本身就是数据文件**，即B+Tree的数据域存储的就是实际的数据，这种索引就是聚集索引。这个索引的key就是数据表的主键，因此InnoDB表数据文件本身就是主索引。