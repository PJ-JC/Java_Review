# 面试题

## 1.MySQL InnoDB存储引擎中的MVCC解决了什么问题，能说下MVCC的实现原理么（vivo）

获得高并发性，通过对普通的SELECT不加锁，直接利用MVCC读取指版本的值，避免了对数据重复加锁的过程。

好处： 读不加锁，读写不冲突。

它**存储了每一行的两个(1)额外的隐藏字段，这两个隐藏字段分别记录了行的创建的时间和删除的时间。**在每个事件发生的时候，每行存储版本号，而不是存储事件实际发生的时间。每次事物的开始这个版本号都会增加。自记录时间开始，每个事物都会保存记录的系统版本号。依照事物的 版本来检查每行的版本号。在事物隔离级别为可重复读的情况下，来看看怎样应用它。

https://www.cnblogs.com/phpper/p/6937650.html

## 2. MyISAM和InnoDB的区别

作者：Oscarwin

**区别：**

- InnoDB**支持事务，MyISAM不支持**，对于InnoDB每一条SQL语言都默认封装成事务，自动提交，这样会影响速度，所以最好把多条SQL语言放在begin和commit之间，组成一个事务；  

- InnoDB**支持外键**，而MyISAM不支持。对一个包含外键的InnoDB表转为MYISAM会失败；  

-  InnoDB是**聚集索引**，数据文件是和索引绑在一起的，**必须要有主键，通过主键索引效率很高**。但是辅助索引需要两次查询，先查询到主键，然后再通过主键查询到数据。因此，主键不应该过大，因为主键太大，其他索引也都会很大。而MyISAM是**非聚集索引，数据文件是分离的，索引保存的是数据文件的指针**。主键索引和辅助索引是独立的。 

- InnoDB**不保存表的具体行数**，执行select count(*) from table时需要全表扫描。而MyISAM用一个变量保存了整个表的行数，执行上述语句时只需要读出该变量即可，速度很快；  

- Innodb不支持全文索引，而MyISAM支持全文索引，查询效率上MyISAM要高；   
- InnoDB**支持表锁，行锁**；MyISAM**支持表锁**，但是InnoDB的行锁，只是在WHERE的主键是有效的，非主键的WHERE都会锁全表的

**如何选择：**

-  是否**要支持事务**，如果要请选择innodb，如果不需要可以考虑MyISAM；
-  如果表中绝大多数都只是**读查询**，可以考虑MyISAM，如果**既有读写也挺频繁**，请使用InnoDB。
-  系统奔溃后，MyISAM**恢复起来更困难**，能否接受；
-   MySQL5.5版本开始Innodb已经成为Mysql的默认引擎(之前是MyISAM)，说明其优势是有目共睹的，如果你不知道用什么，那就用InnoDB，至少不会差。

## 3. InnoDB里实现了哪几种锁？（作业帮）

共享锁：允许事务读一行数据

排他锁：允许事务删除或更新一行数据

意向共享锁、意向排他锁

记录锁

间隙锁

next-key临键锁

自增锁

https://www.jianshu.com/p/8c0c9d3b0306

## 4. InnoDB的redo log和MySQL的binlog有什么异同？



## 5. 为什么要建议用自增列做主键

如果表使用自增主键，那么每次插入新的记录，记录就会**顺序添加到当前索引节点的后续位置，当一页写满，就会自动开辟一个新的页。**

使用自增列(INT/BIGINT类型)做主键，这时候写入顺序是自增的，和**B+数叶子节点分裂顺序一致，存取效率是最高的**

## 6. 为什么MySQL的索引要使用B+树而不是其它树形结构?比如B树？

因为B树不管叶子节点还是非叶子节点，都会保存数据，这样导致在非叶子节点中能保存的指针数量变少（有些资料也称为扇出）

指针少的情况下要保存大量数据，**只能增加树的高度，导致IO操作变多，查询性能变低；**

## 7. innodb引擎的4大特性

插入缓冲（insert buffer),二次写(double write),自适应哈希索引(ahi),预读(read ahead)

## 8. innodb的索引有哪些和底层实现是怎么样的?（小米）

B+树索引 FULLTEXT索引

## 9.Innodb和MyIsam的叶子节点存的是什么

InnoDB的的二级索引的叶子节点存放的是**KEY字段加主键值**。因此，通过二级索引查询首先查到是主键值，然后InnoDB再根据查到的**主键值通过主键索引找到相应的数据块**。
而MyISAM的二级索引叶子节点存放的还是列值与行号的组合，叶子节点中保存的是**数据的物理地址**。所以可以看出MYISAM的主键索引和二级索引没有任何区别，主键索引仅仅只是一个叫做PRIMARY的唯一、非空的索引，且MYISAM引擎中可以不设主键

https://www.cnblogs.com/qlqwjy/p/7770580.html

## 10.InnoDB的一棵B+树可以存放多少行数据？

**约2千万**

https://blog.csdn.net/kexuanxiu1163/article/details/100571361

# MySQL各大存储引擎

- InnoDB 
- MyIsam 
- Memory（也叫HEAP）
- Mrg_Myisam：（分表的一种方式–水平分表）
- Blackhole（黑洞引擎）

## InnoDB

InnoDB是一个事务型的存储引擎，有行级锁定和外键约束。

### 适用场景：

1）经常更新的表，适合处理多重并发的更新请求。
2）支持事务。
3）可以从灾难中恢复（通过bin-log日志等）。
4）外键约束。只有他支持外键。
5）支持自动增加列属性auto_increment。

## MYIsaM

MyIASM是MySQL默认的引擎，但是它**没有提供对数据库事务的支持，也不支持行级锁和外键**，因此当INSERT(插入)或UPDATE(更新)数据时即写操作需要锁定整个表，效率便会低一些。

### 适用场景：

1）不支持事务的设计，但是并不代表着有事务操作的项目不能用MyIsam存储引擎，可以在service层进行根据自己的业务需求进行相应的控制。
2）不支持外键的表设计。
3）查询速度很快，如果数据库insert和update的操作比较多的话比较适用。
4）整天 对表进行加锁的场景。
5）MyISAM极度强调快速读取操作。
6）MyIASM中存储了表的行数，于是SELECT COUNT(*) FROM TABLE时只需要直接读取已经保存好的值而不需要进行全表扫描。如果表的读操作远远多于写操作且不需要数据库事务的支持，那么MyIASM也是很好的选择。

# InnoDB和MyIsam使用及其原理对比

1）事务。MyISAM类型**不支持事务处理等高级处理**，而InnoDB类型**支持，提供事务支持**已经外部键等高级数据库功能。

2）性能主题。MyISAM类型的表**强调的是性能**，其执行数度比InnoDB类型更快。

3）行数保存。InnoDB 中不保存表的具体行数，也就是说，执行select count() fromtable时，InnoDB要扫描一遍整个表来计算有多少行，但是MyISAM只要简单的读出保存好的行数即可。注意的是，当count()语句包含where条件时，两种表的操作是一样的。

4）索引存储。对于AUTO_INCREMENT类型的字段，InnoDB中必须包含只有该字段的索引，但是在MyISAM表中，可以和其他字段一起建立联合索引。

5）服务器数据备份。InnoDB必须导出SQL来备份，LOAD TABLE FROM MASTER操作对InnoDB是不起作用的，解决方法是首先把InnoDB表改成MyISAM表，导入数据后再改成InnoDB表，但是对于使用的额外的InnoDB特性(例如外键)的表不适用。
而且MyISAM应对错误编码导致的数据恢复速度快。MyISAM的数据是以文件的形式存储，所以在跨平台的数据转移中会很方便。在备份和恢复时可单独针对某个表进行操作。

6）锁的支持。MyISAM只支持**表锁**。InnoDB**支持表锁、行锁** 行锁大幅度提高了多用户并发操作的新能。但是InnoDB的行锁，只是在WHERE的主键是有效的，非主键的WHERE都会锁全表的

## 使用场景

以下两点必须使用 InnoDB：
1）**可靠性高或者要求事务处理**，则使用InnoDB。这个是必须的。
2）**表更新和查询都相当的频繁**，并且表锁定的机会比较大的情况指定InnoDB数据引擎的创建。

对比之下，MyISAM的使用场景：
1）做**很多count的计算的**。如一些日志，调查的业务表。
2）**插入修改不频繁**，**查询非常频繁的**。

## InnoDB和MyIsam引擎原理：

（1）MyIASM引擎的索引结构：

MyISAM索引结构: MyISAM索引用的**B+ tree来储存数据**，MyISAM索引的指针指向的是**键值的地址，地址存储的是数据。**

B+Tree的数据域存储的内容为实际数据的地址，也就是说它的索引和实际的数据是分开的，只不过是用索引指向了实际的数据，**这种索引就是所谓的非聚集索引**。

（2）InnoDB引擎的索引结构：

也是B+Tree索引结构。Innodb的**索引文件本身就是数据文件**，即B+Tree的数据域存储的就是实际的数据，这种索引就是聚集索引。这个索引的key就是数据表的主键，因此InnoDB表数据文件本身就是主索引。

## innodb字段

innodb存储引擎中，每行数据都包含了一些隐藏字段：DB_ROW_ID、DB_TRX_ID、DB_ROLL_PTR和DELETE_BIT。

DB_TRX_ID：用来标识最近一次对本行记录做修改的事务的标识符，即最后一次修改本行记录的事务id。delete操作在内部来看是一次update操作，更新行中的删除标识位DELELE_BIT。

DB_ROLL_PTR：指向当前数据的**undo log**记录，回滚数据通过这个指针来寻找记录被更新之前的内容信息。

DB_ROW_ID：包含一个随着新行插入而单调递增的行ID, 当由innodb自动产生聚集索引时，聚集索引会包括这个行ID的值，否则这个行ID不会出现在任何索引中。

DELELE_BIT：用于标识该记录是否被删除。数据操作

- insert

  创建一条记录，DB_TRX_ID为当前事务ID，DB_ROLL_PTR为NULL。

- delete

  将当前行的DB_TRX_ID设置为当前事务ID，DELELE_BIT设置为1。

- update 复制一行，新行的DB_TRX_ID为当前事务ID，DB_ROLL_PTR指向上个版本的记录，事务提交后DB_ROLL_PTR设置为NULL。

- select

  1、只查找创建早于当前事务ID的记录，确保当前事务读取到的行都是事务之前就已经存在的，或者是由当前事务创建或修改的；

  2、行的DELETE BIT为1时，查找删除晚于当前事务ID的记录，确保当前事务开始之前，行没有被删除。

  作者：梦之痕链接：https://juejin.im/post/5c519bb8f265da617831cfff