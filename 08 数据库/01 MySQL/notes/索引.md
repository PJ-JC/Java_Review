# 面试题

## 1.主键、外键和索引的区别？（华为）

|        | 主键                                           | 外键                                                     | 索引                               |
| ------ | ---------------------------------------------- | -------------------------------------------------------- | ---------------------------------- |
| 定义： | **唯一标识一条记录，不能有重复的，不允许为空** | **表的外键是另一表的主键, 外键可以有重复的, 可以是空值** | 该字段没有重复值，但可以有一个空值 |
| 作用： | 用来保证数据完整性                             | 用来和其他表建立联系用的                                 | 是提高查询排序的速度               |
| 个数： | 主键只能有一个                                 | 一个表可以有多个惟一索引                                 | 一个表可以有多个惟一索引           |

## 2.建立索引的原则 （华数）

- 为经常需要**排序，分组和联合操作**的字段建立索引
- 为常作为**查询条件的字段建**立索引
- 限制索引的数目
- 选择唯一性索引
- 尽量使用前缀的索引
- 最左前缀索引

不应建立索引的列

第一，对于那些**在查询中很少使用或者参考的列不应该创建索引**。这是因为，既然这些列很少使用到，因此有索引或者无索引，并不能提高查询速度。相反，由于增加了索引，反而降低了系统的维护速度和增大了空间需求。

第二，对于那些**只有很少数据值的列也不应该增加索引**。这是因为，由于这些列的取值很少，例如人事表的性别列，在查询的结果中，结果集的数据行占了表中数据行的很大比例，即需要在表中搜索的数据行的比例很大。增加索引，并不能明显加快检索速度。

第三，对于那些定义为text, image和bit数据类型的列不应该增加索引。这是因为，这些列的数据量要么相当大，要么取值很少。

第四，**当修改性能远远大于检索性能时，不应该创建索引。**这是因为，**修改性能和检索性能是互相矛盾的**。当增加索引时，会提高检索性能，但是会降低修改性能。当减少索引时，会提高修改性能，降低检索性能。因此，当修改性能远远大于检索性能时，不应该创建索引。

根据数据库的功能，可以在[数据库设计](http://www.2cto.com/database/)器中创建三种索引：**唯一索引、主键索引和聚集索引**。

## 3. 联合索引和单列索引的区别（涂鸦智能）



## 4.聚集索引和非聚集索引

InnoDB存储引擎表示索引组织表，即表中数据按照主键顺序存放。而**聚集索引（clustered index）就是按照每张表的主键构造一棵B+树，同时叶子结点存放的即为整张表的行记录数据，也将聚集索引的叶子结点称为数据页。**聚集索引的这个特性决定了索引组织表中数据也是索引的一部分。

聚集索引的好处之一：**它对主键的排序查找和范围查找速度非常快**，叶子节点的数据就是用户所要查询的数据。如用户需要查找一张表，查询最后的10位用户信息，由于B+树索引是双向链表，所以用户可以快速找到最后一个数据页，并取出10条记录

聚集索引的好处之二：范围查询（range query），即如果要查找主键某一范围内的数据，通过叶子节点的上层中间节点就可以得到页的范围，之后直接读取数据页即可

表中除了聚集索引外其他索引都是辅助索引（Secondary Index，也称为非聚集索引），与聚集索引的区别是：辅助索引的叶子节点不包含行记录的全部数据。

叶子节点除了包含键值以外，每个叶子节点中的索引行中还包含一个书签（bookmark）。该书签用来告诉InnoDB存储引擎去哪里可以找到与索引相对应的行数据

https://www.jb51.net/article/140749.htm

https://cloud.tencent.com/developer/article/1125452

# 索引

索引是一种用于快速找到记录的**一种数据结构。**

索引是在**存储引擎层实现**的，而不是在服务器层实现的，所以不同存储引擎具有不同的索引类型和实现。

索引能够轻易将查询性能提升几个数量级。

1. 对于非常小的表、大部分情况下简单的全表扫描比建立索引更高效。

1. 对于中到大型的表，索引就非常有效。

1. 但是对于特大型的表，建立和使用索引的代价将会随之增长。这种情况下，需要用到一种技术可以直接区分出需要查询的一组数据，而不是一条记录一条记录地匹配，例如可以使用分区技术。

## 索引类型

### B+ Tree 索引

B-Tree 索引是大多数 MySQL 存储引擎的**默认索引类型**。

因为不再需要进行全表扫描，只需要对树进行搜索即可，因此查找速度快很多。

可以指定多个列作为索引列，多个索引列共同组成键。

B-Tree 索引适用于**全键值、键值范围和键前缀查找**，其中键前缀查找只适用于最左前缀查找。

除了用于查找，还可以用于排序和分组。

如果不是按照索引列的顺序进行查找，则无法使用索引。

### 哈希索引

基于哈希表实现，优点是**查找非常快**。

在 MySQL 中只有 Memory 引擎显式支持哈希索引。

InnoDB 引擎有一个特殊的功能叫“自适应哈希索引”，当某个索引值被使用的非常频繁时，会在 B-Tree 索引之上再创建一个哈希索引，这样就让 B-Tree 索引具有哈希索引的一些优点，比如快速的哈希查找。

限制：哈希索引只包含哈希值和行指针，**而不存储字段值，所以不能使用索引中的值来避免读取行**。

不过，访问内存中的行的速度很快，所以大部分情况下这一点对性能影响并不明显；无法用于分组与排序；只支持精确查找，无法用于部分查找和范围查找；如果哈希冲突很多，查找速度会变得很慢。

无法用于排序和分组。

### 空间索引数据（R-Tree）

MyISAM 存储引擎支持空间索引，可以用于地理数据存储。

空间索引会从所有维度来索引数据，可以有效地使用任意维度来进行组合查询。

### 全文索引

MyISAM 存储引擎支持全文索引，用于查找文本中的关键词，而不是直接比较索引中的值。

使用 MATCH AGAINST，而不是普通的 WHERE。

## 索引的优点

- 大大**减少了服务器需要扫描的数据量**；

- 帮助服务器避免进行排序和创建临时表；

- 将随机 I/O 变为顺序 I/O。

## 索引的缺点

- **创建索引和维护索引要耗费时间**，这种时间随着数据量的增加而增加

- 索引需要**占用物理空间**，除了数据表占用数据空间之外，每一个索引还要占一定的物理空间，如果建立聚簇索引，那么需要的空间就会更大

- 当对表中的数据进行增加、删除和修改的时候，索引也需要维护，降低数据维护的速度

## 索引优化

### 独立的列

在进行查询时，索引列不能是表达式的一部分，也不能是函数的参数，否则无法使用索引。

例如下面的查询不能使用 actor_id 列的索引：

```sql
SELECT actor_id FROM sakila.actor WHERE actor_id + 1 = 5;
```

### 前缀索引

对于 BLOB、TEXT 和 VARCHAR 类型的列，必须使用前缀索引，只索引开始的部分字符。

对于前缀长度的选取需要根据 **索引选择性** 来确定：不重复的索引值和记录总数的比值。选择性越高，查询效率也越高。最大值为 1 ，此时每个记录都有唯一的索引与其对应。

### 多列索引

在需要使用多个列作为条件进行查询时，使用多列索引比使用多个单列索引性能更好。例如下面的语句中，最好把 actor_id 和 file_id 设置为多列索引。

```sql
SELECT file_id, actor_ id FROM sakila.film_actor
WhERE actor_id = 1 OR film_id = 1;
```

### 索引列的顺序

让选择性最强的索引列放在前面，例如下面显示的结果中 customer_id 的选择性比 staff_id 更高，因此最好把 customer_id 列放在多列索引的前面。

```sql
SELECT COUNT(DISTINCT staff_id)/COUNT(*) AS staff_id_selectivity,
COUNT(DISTINCT customer_id)/COUNT(*) AS customer_id_selectivity,
COUNT(*)
FROM payment;
```

```html
   staff_id_selectivity: 0.0001
customer_id_selectivity: 0.0373
               COUNT(*): 16049
```

### 聚簇索引

聚簇索引并不是一种索引类型，而是一种**数据存储方式**。

术语“聚簇”表示数据行和相邻的键值紧密地存储在一起，InnoDB 的聚簇索引的数据行存放在 B-Tree 的叶子页中。

因为无法把数据行存放在两个不同的地方，所以一个表只能有一个聚簇索引。

**优点**

1. 可以把相关数据保存在一起，减少 I/O 操作；
2. 因为数据保存在 B-Tree 中，因此数据访问更快。

**缺点**

1. 聚簇索引最大限度提高了 I/O 密集型应用的性能，但是如果数据全部放在内存，就没必要用聚簇索引。
2. 插入速度严重依赖于插入顺序，按主键的顺序插入是最快的。
3. 更新操作代价很高，因为每个被更新的行都会移动到新的位置。
4. 当插入到某个已满的页中，存储引擎会将该页分裂成两个页面来容纳该行，页分裂会导致表占用更多的磁盘空间。
5. 如果行比较稀疏，或者由于页分裂导致数据存储不连续时，聚簇索引可能导致全表扫描速度变慢。

### 覆盖索引

索引包含所有需要查询的字段的值。

## 最左前缀原则

MySQL中的索引可以以一定顺序引用多列，这种索引叫作联合索引。如User表的name和city加联合索引就是(name,city)，而最左前缀原则指的是，如果查询的时候查询条件**精确匹配索引的左边连续一列或几列**，则此列就可以被用到。如下：

    select * from user where name=xx and city=xx ; ／／可以命中索引
    select * from user where name=xx ; // 可以命中索引
    select * from user where city=xx ; // 无法命中索引

## 如何为表字段添加索引

1.添加PRIMARY KEY（主键索引）

	ALTER TABLE `table_name` ADD PRIMARY KEY ( `column` ) 

2.添加UNIQUE(唯一索引)

	ALTER TABLE `table_name` ADD UNIQUE ( `column` ) 

3.添加INDEX(普通索引)

	ALTER TABLE `table_name` ADD INDEX index_name ( `column` )

4.添加FULLTEXT(全文索引)

	ALTER TABLE `table_name` ADD FULLTEXT ( `column`)

5.添加多列索引

	ALTER TABLE `table_name` ADD INDEX index_name ( `column1`, `column2`, `column3` )