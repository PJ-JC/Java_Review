# 面试题

## 1.主键、外键和索引的区别？（华为）

|        | 主键                                           | 外键                                                     | 索引                               |
| ------ | ---------------------------------------------- | -------------------------------------------------------- | ---------------------------------- |
| 定义： | **唯一标识一条记录，不能有重复的，不允许为空** | **表的外键是另一表的主键, 外键可以有重复的, 可以是空值** | 该字段没有重复值，但可以有一个空值 |
| 作用： | 用来保证数据完整性                             | 用来和其他表建立联系用的                                 | 是提高查询排序的速度               |
| 个数： | 主键只能有一个                                 | 一个表可以有多个惟一索引                                 | 一个表可以有多个惟一索引           |

## 2.建立索引的原则 （华数）

- 为经常需要**排序，分组和联合操作**的字段建立索引
- 为常作为**查询条件的字段建**立索引
- 限制索引的数目
- 选择唯一性索引
- 尽量使用前缀的索引
- 最左前缀索引

不应建立索引的列

第一，对于那些**在查询中很少使用或者参考的列不应该创建索引**。这是因为，既然这些列很少使用到，因此有索引或者无索引，并不能提高查询速度。相反，由于增加了索引，反而降低了系统的维护速度和增大了空间需求。

第二，对于那些**只有很少数据值的列也不应该增加索引**。这是因为，由于这些列的取值很少，例如人事表的性别列，在查询的结果中，结果集的数据行占了表中数据行的很大比例，即需要在表中搜索的数据行的比例很大。增加索引，并不能明显加快检索速度。

第三，对于那些定义为text, image和bit数据类型的列不应该增加索引。这是因为，这些列的数据量要么相当大，要么取值很少。

第四，**当修改性能远远大于检索性能时，不应该创建索引。**这是因为，**修改性能和检索性能是互相矛盾的**。当增加索引时，会提高检索性能，但是会降低修改性能。当减少索引时，会提高修改性能，降低检索性能。因此，当修改性能远远大于检索性能时，不应该创建索引。

根据数据库的功能，可以在[数据库设计](http://www.2cto.com/database/)器中创建三种索引：**唯一索引、主键索引和聚集索引**。

## 3. 联合索引和单列索引的区别（涂鸦智能）



## 4.聚集索引和非聚集索引

InnoDB存储引擎表示索引组织表，即表中数据按照主键顺序存放。而**聚集索引（clustered index）就是按照每张表的主键构造一棵B+树，同时叶子结点存放的即为整张表的行记录数据，也将聚集索引的叶子结点称为数据页。**聚集索引的这个特性决定了索引组织表中数据也是索引的一部分。

聚集索引的好处之一：**它对主键的排序查找和范围查找速度非常快**，叶子节点的数据就是用户所要查询的数据。如用户需要查找一张表，查询最后的10位用户信息，由于B+树索引是双向链表，所以用户可以快速找到最后一个数据页，并取出10条记录

聚集索引的好处之二：范围查询（range query），即如果要查找主键某一范围内的数据，通过叶子节点的上层中间节点就可以得到页的范围，之后直接读取数据页即可

表中除了聚集索引外其他索引都是辅助索引（Secondary Index，也称为非聚集索引），与聚集索引的区别是：辅助索引的叶子节点不包含行记录的全部数据。

叶子节点除了包含键值以外，每个叶子节点中的索引行中还包含一个书签（bookmark）。该书签用来告诉InnoDB存储引擎去哪里可以找到与索引相对应的行数据

https://www.jb51.net/article/140749.htm

https://cloud.tencent.com/developer/article/1125452

## 5. 说说什么是索引（阿里）

一种数据结构，能够帮助我们快速的检索数据库中的数据。

## 6. 索引采用哪种数据结构（阿里）

常见的两种数据结构B+ Tree索引 和 Hash索引。

## 7. 为什么InnoDB使用B+树的索引模型，为什么采用B+树，和Hash索引比有什么优缺点（阿里）

Hash索引底层是哈希表，哈希表是一种以key-value存储数据的结构，所以多个数据在存储关系上是**完全没有任何顺序**关系的，所以，对于区间查询是无法直接通过索引查询的，就**需要全表扫描**。**所以，哈希索引只适用于等值查询的场景。**而B+ 树是一种**多路平衡查询树**，所以他的节点是天然有序的（左子节点小于父节点、父节点小于右子节点），所以对于范围查询的时候不需要做全表扫描

哈希索引适合**等值查询**，但是**无法进行范围查询** 

哈希索引没办法**利用索引完成排序** 

哈希索引不支持**多列联合索引的最左匹配规则** 

如果有大量重复键值的情况下，哈希索引的效率会很低，因为**存在哈希碰撞问题**

## 8. **在创建联合索引的时候，需要做联合索引多个字段之间顺序你们是如何选择的呢？** （阿里）

最左前缀原则，把识别度最高的字段放到最前面。

## 9. SQL语句有没有使用索引查询统计过吗，有什么手段知道有没有走索引查询？（阿里）

通过explain查看sql语句的优化计划，通过执行计划来分析索引使用情况。

## 10. 索引什么时候会失效（cvte）

1. 如果**条件中有or**，即使其中有条件带索引也不会使用(**这也是为什么尽量少用or的原因**)
2. 对于**多列索引，不是使用的第一部分，则不会使用索引**
3. **like查询是以%开头**
4. 如果列类型是字符串，那一定要在条件中将数据使用引号引用起来,否则不使用索引
5. 如果mysql估计**使用全表扫描要比使用索引快,**则不使用索引

## 11. a，b，c三列，建立a,b,c联合索引，只使用a,b能命中索引吗（字节）

根据查询字段的位置不同来决定，**如查询a,     a,b    a,b,c    a,c   都可以走索引的，其他条件的查询不能走索引。**

组合索引 **有“最左前缀”原则**。就是只从最左面的开始组合，并不是所有只要含有这三列存在的字段的查询都会用到该组合索引。

https://www.cnblogs.com/guopengxia0719/p/10482539.html

## 12. 什么时候不适用索引

（1）**表记录太少**；

（2）**数据重复且分布平均的字段**（只有很少数据值的列）；

（3）**经常插入、删除、修改的表要减少索引**；

（4）text，image等类型不应该建立索引，这些列的数据量大（假如text前10个字符唯一，也可以对text前10个字符建立索引）；

（5）MySQL能估计出全表扫描比使用索引更快时，不使用索引；

---------------------
作者：绕远的偶人 
原文：https://blog.csdn.net/weixin_39420024/article/details/80040549 


# 索引

索引是一种用于快速找到记录的**一种数据结构。**

索引是在**存储引擎层实现**的，而不是在服务器层实现的，所以不同存储引擎具有不同的索引类型和实现。

索引能够轻易将查询性能提升几个数量级。

1. 对于非常小的表、大部分情况下简单的全表扫描比建立索引更高效。

1. 对于中到大型的表，索引就非常有效。

1. 但是对于特大型的表，建立和使用索引的代价将会随之增长。这种情况下，需要用到一种技术可以直接区分出需要查询的一组数据，而不是一条记录一条记录地匹配，例如可以使用分区技术。

## 索引类型

### B+ Tree 索引

B-Tree 索引是大多数 MySQL 存储引擎的**默认索引类型**。

因为不再需要进行全表扫描，只需要对树进行搜索即可，因此查找速度快很多。

可以指定多个列作为索引列，多个索引列共同组成键。

B-Tree 索引适用于**全键值、键值范围和键前缀查找**，其中键前缀查找只适用于最左前缀查找。

除了用于查找，还可以用于排序和分组。

如果不是按照索引列的顺序进行查找，则无法使用索引。

### 哈希索引

基于哈希表实现，优点是**查找非常快**。

在 MySQL 中只有 Memory 引擎显式支持哈希索引。

InnoDB 引擎有一个特殊的功能叫“自适应哈希索引”，当某个索引值被使用的非常频繁时，会在 B-Tree 索引之上再创建一个哈希索引，这样就让 B-Tree 索引具有哈希索引的一些优点，比如快速的哈希查找。

限制：哈希索引只包含哈希值和行指针，**而不存储字段值，所以不能使用索引中的值来避免读取行**。

不过，访问内存中的行的速度很快，所以大部分情况下这一点对性能影响并不明显；无法用于分组与排序；只支持精确查找，无法用于部分查找和范围查找；如果哈希冲突很多，查找速度会变得很慢。

无法用于排序和分组。

### 空间索引数据（R-Tree）

MyISAM 存储引擎支持空间索引，可以用于地理数据存储。

空间索引会从所有维度来索引数据，可以有效地使用任意维度来进行组合查询。

### 全文索引

MyISAM 存储引擎支持全文索引，用于查找文本中的关键词，而不是直接比较索引中的值。

使用 MATCH AGAINST，而不是普通的 WHERE。

## 索引的优点

- 大大**减少了服务器需要扫描的数据量**；

- 帮助服务器避免进行排序和创建临时表；

- 将随机 I/O 变为顺序 I/O。

## 索引的缺点

- **创建索引和维护索引要耗费时间**，这种时间随着数据量的增加而增加

- 索引需要**占用物理空间**，除了数据表占用数据空间之外，每一个索引还要占一定的物理空间，如果建立聚簇索引，那么需要的空间就会更大

- 当对表中的数据进行增加、删除和修改的时候，索引也需要维护，降低数据维护的速度

## 索引优化

### 独立的列

在进行查询时，索引列不能是表达式的一部分，也不能是函数的参数，否则无法使用索引。

例如下面的查询不能使用 actor_id 列的索引：

```sql
SELECT actor_id FROM sakila.actor WHERE actor_id + 1 = 5;
```

### 前缀索引

对于 BLOB、TEXT 和 VARCHAR 类型的列，必须使用前缀索引，只索引开始的部分字符。

对于前缀长度的选取需要根据 **索引选择性** 来确定：不重复的索引值和记录总数的比值。选择性越高，查询效率也越高。最大值为 1 ，此时每个记录都有唯一的索引与其对应。

### 多列索引

在需要使用多个列作为条件进行查询时，使用多列索引比使用多个单列索引性能更好。例如下面的语句中，最好把 actor_id 和 file_id 设置为多列索引。

```sql
SELECT file_id, actor_ id FROM sakila.film_actor
WhERE actor_id = 1 OR film_id = 1;
```

### 索引列的顺序

让选择性最强的索引列放在前面，例如下面显示的结果中 customer_id 的选择性比 staff_id 更高，因此最好把 customer_id 列放在多列索引的前面。

```sql
SELECT COUNT(DISTINCT staff_id)/COUNT(*) AS staff_id_selectivity,
COUNT(DISTINCT customer_id)/COUNT(*) AS customer_id_selectivity,
COUNT(*)
FROM payment;
```

```html
   staff_id_selectivity: 0.0001
customer_id_selectivity: 0.0373
               COUNT(*): 16049
```

### 聚簇索引

聚簇索引并不是一种索引类型，而是一种**数据存储方式**。

术语“聚簇”表示数据行和相邻的键值紧密地存储在一起，InnoDB 的聚簇索引的数据行存放在 B-Tree 的叶子页中。

因为无法把数据行存放在两个不同的地方，所以一个表只能有一个聚簇索引。

**优点**

1. 可以把相关数据保存在一起，减少 I/O 操作；
2. 因为数据保存在 B-Tree 中，因此数据访问更快。

**缺点**

1. 聚簇索引最大限度提高了 I/O 密集型应用的性能，但是如果数据全部放在内存，就没必要用聚簇索引。
2. 插入速度严重依赖于插入顺序，按主键的顺序插入是最快的。
3. 更新操作代价很高，因为每个被更新的行都会移动到新的位置。
4. 当插入到某个已满的页中，存储引擎会将该页分裂成两个页面来容纳该行，页分裂会导致表占用更多的磁盘空间。
5. 如果行比较稀疏，或者由于页分裂导致数据存储不连续时，聚簇索引可能导致全表扫描速度变慢。

### 覆盖索引

索引包含所有需要查询的字段的值。

具有以下优点：

- 索引通常远小于数据行的大小，只读取索引能大大减少数据访问量。
- 一些存储引擎（例如 MyISAM）在内存中只缓存索引，而数据依赖于操作系统来缓存。因此，只访问索引可以不使用系统调用（通常比较费时）。
- 对于 InnoDB 引擎，若辅助索引能够覆盖查询，则无需访问主索引。

## 最左前缀原则

MySQL中的索引可以以一定顺序引用多列，这种索引叫作联合索引。如User表的name和city加联合索引就是(name,city)，而最左前缀原则指的是，如果查询的时候查询条件**精确匹配索引的左边连续一列或几列**，则此列就可以被用到。如下：

    select * from user where name=xx and city=xx ; ／／可以命中索引
    select * from user where name=xx ; // 可以命中索引
    select * from user where city=xx ; // 无法命中索引

## 如何为表字段添加索引

1.添加PRIMARY KEY（主键索引）

	ALTER TABLE `table_name` ADD PRIMARY KEY ( `column` ) 

2.添加UNIQUE(唯一索引)

	ALTER TABLE `table_name` ADD UNIQUE ( `column` ) 

3.添加INDEX(普通索引)

	ALTER TABLE `table_name` ADD INDEX index_name ( `column` )

4.添加FULLTEXT(全文索引)

	ALTER TABLE `table_name` ADD FULLTEXT ( `column`)

5.添加多列索引

	ALTER TABLE `table_name` ADD INDEX index_name ( `column1`, `column2`, `column3` )