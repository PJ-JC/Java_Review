# 面试题

## 1. 怎么查看一条语句用了什么索引？（oppo）

explain SQL语句

一条查询语句在经过`MySQL`查询优化器的各种基于成本和规则的优化会后生成一个所谓的`执行计划`，这个执行计划展示了接下来具体执行查询的方式，比如多表连接的顺序是什么，对于每个表采用什么访问方法来具体执行查询等等。

如果我们想看看某个查询的执行计划的话，可以在具体的查询语句前边加一个`EXPLAIN`，就像这样：

```mysql
explain  select count(*) from userinfo where  id = 1;
```

|      列名       | 描述                                                         |
| :-------------: | :----------------------------------------------------------- |
|      `id`       | 在一个大的查询语句中每个`SELECT`关键字都**对应一个唯一的id** |
|  `select_type`  | `SELECT`关键字对应的那个查询的类型                           |
|     `table`     | 表名                                                         |
|  `partitions`   | 匹配的分区信息                                               |
|     `type`      | 针对单表的访问方法                                           |
| `possible_keys` | 可能用到的索引                                               |
|      `key`      | 实际上使用的索引                                             |
|    `key_len`    | 实际使用到的索引长度                                         |
|      `ref`      | 当使用索引列等值查询时，与索引列进行等值匹配的对象信息       |
|     `rows`      | 预估的需要读取的记录条数                                     |
|   `filtered`    | 某个表经过搜索条件过滤后剩余记录条数的百分比                 |
|     `Extra`     | 一些额外的信息                                               |

## 执行计划输出中各列详解

type显示的是访问类型，是较为重要的一个指标，结果值从好到坏依次是： system > const > eq_ref > ref > fulltext > ref_or_null > index_merge > unique_subquery > index_subquery > range > index > ALL ，一般来说，得保证查询至少达到range级别，最好能达到ref。

| 类型   | 说明                                                         |
| :----- | :----------------------------------------------------------- |
| All    | 最坏的情况,全表扫描                                          |
| index  | 和全表扫描一样。只是扫描表的时候按照索引次序进行而不是行。主要优点就是避免了排序, 但是开销仍然非常大。如在Extra列看到Using index，说明正在使用覆盖索引，只扫描索引的数据，它比按索引次序全表扫描的开销要小很多 |
| range  | 范围扫描，一个有限制的索引扫描。key 列显示使用了哪个索引。当使用=、 <>、>、>=、<、<=、IS NULL、<=>、BETWEEN 或者 IN 操作符,用常量比较关键字列时,可以使用 range |
| ref    | 一种索引访问，它返回所有匹配某个单个值的行。此类索引访问只有当使用非唯一性索引或唯一性索引非唯一性前缀时才会发生。这个类型跟eq_ref不同的是，它用在关联操作只使用了索引的最左前缀，或者索引不是UNIQUE和PRIMARY KEY。ref可以用于使用=或<=>操作符的带索引的列。 |
| eq_ref | 最多只返回一条符合条件的记录。使用唯一性索引或主键查找时会发生 （高效） |
| const  | 当确定最多只会有一行匹配的时候，MySQL优化器会在查询前读取它而且只读取一次，因此非常快。当主键放入where子句时，mysql把这个查询转为一个常量（高效） |
| system | 这是const连接类型的一种特例，表仅有一行满足条件。            |
| Null   | 意味说mysql能在优化阶段分解查询语句，在执行阶段甚至用不到访问表或索引（高效） |


作者：何甜甜在吗链接：https://juejin.im/post/5bcc2935f265da0ac66987c9