# 面试题

## 1.乐观锁实际上有没有加锁？（百度）

没有

## 2.乐观锁的实现，画图（百度）

乐观锁的概念中其实已经阐述了他的具体实现细节：主要就是两个步骤：冲突检测和数据更新。其实现方式有一种比较典型的就是Compare and Swap(CAS)。

CAS是项乐观锁技术，当多个线程尝试使用CAS同时更新同一个变量时，只有其中一个线程能更新变量的值，而其它线程都失败，失败的线程并不会被挂起，而是被告知这次竞争中失败，并可以再次尝试。

比如前面的扣减库存问题，通过乐观锁可以实现如下：

```mysql
//查询出商品库存信息，quantity = 3
select quantity from items where id=1
//修改商品库存为2
update items set quantity=2 where id=1 and quantity = 3;
```

以上，我们在更新之前，先查询一下库存表中当前库存数（quantity），然后在做update的时候，以库存数作为一个修改条件。当我们提交更新的时候，判断数据库表对应记录的当前库存数与第一次取出来的库存数进行比对，如果数据库表当前库存数与第一次取出来的库存数相等，则予以更新，否则认为是过期数据。

￼有一个比较好的办法可以解决ABA问题，那就是通过一个单独的可以顺序递增的**version字段**。改为以下方式即可：

```mysql
//查询出商品信息，version = 1
select version from items where id=1
//修改商品库存为2
update items set quantity=2,version = 3 where id=1 and version = 2;
复制代码
```

乐观锁每次在执行数据的修改操作时，都会带上一个版本号，一旦版本号和数据的版本号一致就可以执行修改操作并**对版本号执行+1操作，否则就执行失败**。因为每次操作的版本号都会随之增加，所以不会出现ABA问题，因为版本号只会增加不会减少。

以上SQL其实还是有一定的问题的，就是**一旦发上高并发的时候，就只有一个线程可以修改成功，那么就会存在大量的失败。**

对于像淘宝这样的电商网站，高并发是常有的事，总让用户感知到失败显然是不合理的。所以，还是要想办法**减少乐观锁的粒度的。**

有一条比较好的建议，可以**减小乐观锁力度，最大程度的提升吞吐率，提高并发能力！**如下：

```java
//修改商品库存
update item 
set quantity=quantity - 1 
where id = 1 and quantity - 1 > 0
```

以上SQL语句中，如果用户下单数为1，则通过`quantity - 1 > 0`的方式进行乐观锁控制。

以上update语句，在执行过程中，会在一次原子操作中自己查询一遍quantity的值，并将其扣减掉1。

**高并发环境下锁粒度把控是一门重要的学问，选择一个好的锁，在保证数据安全的情况下，可以大大提升吞吐率，进而提升性能。**

作者：漫话编程链接：https://juejin.im/post/5caaaa67e51d452b63241954

## 3.悲观锁的实现

- 在对记录进行修改前，先尝试为该记录**加上排他锁（exclusive locking）**。
- 如果加锁失败，说明该记录正在被修改，那么当前查询可能要等待或者抛出异常。具体响应方式由开发者根据实际需要决定。
- 如果成功加锁，那么就可以对记录做修改，**事务完成后就会解锁了**。
- 其间如果有其他对该记录做修改或加排他锁的操作，都会**等待我们解锁或直接抛出异常**。

要使用悲观锁，我们必须关闭mysql数据库的自动提交属性，因为MySQL默认使用autocommit模式，也就是说，当你执行一个更新操作后，MySQL会立刻将结果进行提交。set autocommit=0;

我们举一个简单的例子，如淘宝下单过程中扣减库存的需求说明一下如何使用悲观锁：

```mysql
//0.开始事务
begin; 
//1.查询出商品库存信息
select quantity from items where id=1 for update;
//2.修改商品库存为2
update items set quantity=2 where id = 1;
//3.提交事务
commit;
```

以上，在对id = 1的记录修改前，**先通过for update的方式进行加锁，然后再进行修改。**这就是比较典型的悲观锁策略。

上面我们提到，使用select…for update会把数据给锁住，不过我们需要注意一些锁的级别，MySQL **InnoDB默认行级锁**。行级锁都是基于索引的，如果一条SQL语句**用不到索引是不会使用行级锁的，会使用表级锁把整张表锁住**，这点需要注意。
作者：漫话编程链接：https://juejin.im/post/5caaaa67e51d452b63241954

## 4. 如何选择乐观锁和悲观锁

1、乐观锁并未真正加锁，效率高。一旦锁的粒度掌握不好，**更新失败的概率就会比较高**，容易发生业务失败。

2、悲观锁依赖数据库锁，效率低。**更新失败的概率比较低**。

## 5. 行锁的三种算法

https://blog.csdn.net/weixin_34006468/article/details/88039873

## 6. 插入和查询分别用的是什么锁

插入用的排他锁，查询用的共享锁

# 锁分类

从数据库系统角度分为三种：排他锁、共享锁、更新锁。 
从程序员角度分为两种：一种是悲观锁，一种乐观锁。

## 悲观锁

顾名思义，很悲观，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人拿这个数据就会block（阻塞），直到它拿锁。

传统的关系数据库里用到了很多这种锁机制，比如行锁、表锁、读锁、写锁等，都是在操作之前先上锁。

## 悲观锁按使用性质划分

### 共享锁（Share Lock）

共享锁又称读锁（read lock），是读取操作创建的锁。其他用户**可以并发读取数据，但任何事务都不能对数据进行修改**（获取数据上的排他锁），直到已释放所有共享锁。

性质 

1. 多个事务可封锁同一个共享页； 
2. 任何事务都不能修改该页； 
3. 通常是该页被读取完毕，S锁立即被释放。

在SQL Server中，默认情况下，数据被读取后，立即释放共享锁。 
例如，执行查询语句“SELECT * FROM my_table”时，首先锁定第一页，读取之后，释放对第一页的锁定，然后锁定第二页。这样，就允许在读操作过程中，修改未被锁定的第一页。 
例如，语句“SELECT * FROM my_table HOLDLOCK”就要求在整个查询过程中，保持对表的锁定，直到查询完成才释放锁定。

    sql select * from table where ... lock in share mode

#### 总结

一句总结：**会阻塞其他事务修改表数据**。

若事务T对数据对象A加上S锁，则其他事务只能再对A加S锁，而不能X锁，直到T释放A上的锁。这就保证了其他事务可以读A，但在T释放A上的S锁之前不能对A做任何修改。
X锁和S锁都是加载某一个数据对象上的。也就是数据的粒度。

### 排他锁（Exclusive Lock）

X锁，也叫写锁，表示对数据进行写操作。**如果一个事务对对象加了排他锁，其他事务就不能再给它加任何锁了**。（某个顾客把试衣间从里面反锁了，其他顾客想要使用这个试衣间，就只有等待锁从里面打开了。） 
性质 

1. 仅允许一个事务封锁此页； 
2. 其他任何事务必须等到X锁被释放才能对该页进行访问； 
3. X锁一直到事务结束才能被释放。

产生排他锁的SQL语句如下

    sql select * from table where ... for update

#### 总结

**会阻塞其他事务读和写**。

若事务T对数据对象A加上X锁，则只允许T读取和修改A，其他任何事务都不能再对加任何类型的锁，直到T释放A上的锁。这就保证了其他事务在T释放A上的锁之前不能再读取和修改A。

### 更新锁

U锁，在修改操作的初始化阶段用来锁定可能要被修改的资源，这样可以避免使用共享锁造成的死锁现象。

因为当使用共享锁时，修改数据的操作分为两步： 
1. 首先获得一个共享锁，读取数据， 
2. 然后将共享锁升级为排他锁，再执行修改操作。 
这样如果有两个或多个事务同时对一个事务申请了共享锁，在**修改数据时，这些事务都要将共享锁升级为排他锁**。这时，这些事务都不会释放共享锁，而是一直等待对方释放，这样就造成了死锁。 
**如果一个数据在修改前直接申请更新锁，在数据修改时再升级为排他锁，就可以避免死锁**。

性质 
1. 用来预定要对此页施加X锁，它允许其他事务读，但不允许再施加U锁或X锁； 
2. 当被读取的页要被更新时，则升级为X锁； 
3. U锁一直到事务结束时才能被释放。

## 悲观锁按作用范围划分为：行锁、表锁。

### 行锁

行锁又分**共享锁和排他锁**,由字面意思理解，就是给某一行加上锁，也就是一条记录加上锁。

注意：行级锁都是基于索引的，如果一条SQL语句用**不到索引是不会使用行级锁的**，会使用表级锁。

#### 总结

一句总结：行级锁：开销大，加锁慢；会出现死锁；**锁定粒度最小，发生锁冲突的概率最低，并发度也最高**。

详细：行级锁定最大的特点就是锁定对象的颗粒度很小，也是目前各大数据库管理软件所实现的锁定颗粒度最小的。由于锁定颗粒度很小，所以发生锁定资源争用的概率也最小，能够给予应用程序尽可能大的并发处理能力而提高一些需要高并发应用系统的整体性能。

缺陷：由于锁定资源的颗粒度很小，所以每次获取锁和释放锁需要做的事情也更多，带来的消耗自然也就更大了。此外，行级锁定也最**容易发生死锁**。

### 表锁

锁的作用范围是整张表。

MyIsam 实现了表锁。表锁可以针对数据库表加锁，在锁的灵活性上不如行锁。表锁分为两种锁：**读锁与写锁**。

数据库能够确定那些行需要锁的情况下使用行锁，如果不知道会影响哪些行的时候就会使用表锁。

#### 总结

一句总结：表级锁：开销小，加锁快；不会出现死锁；**锁定粒度大，发生锁冲突的概率最高，并发度最低**。

详细：和行级锁定相反，表级别的锁定是MySQL各存储引擎中最大颗粒度的锁定机制。该锁定机制最大的特点是实现逻辑非常简单，带来的系统负面影响最小。所以获取锁和释放锁的速度很快。由于表级锁一次会将整个表锁定，所以可以很好的**避免困扰我们的死锁问题**。

缺陷：锁定颗粒度大所带来最大的负面影响就是出现锁定资源争用的概率也会最高，致使并发度大打折扣。

## 乐观锁的实现方式

顾名思义，就是很乐观，每次自己操作数据的时候认为没有人回来修改它，所以不去加锁，但是**在更新的时候会去判断在此期间数据有没有被修改**，需要用户自己去实现。

对于读操作远多于写操作的时候，大多数都是读取，这时候一个更新操作加锁会阻塞所有读取，降低了吞吐量。最后还要释放锁，锁是需要一些开销的，我们只要想办法解决极少量的更新操作的同步问题。换句话说，**如果是读写比例差距不是非常大或者你的系统没有响应不及时**，吞吐量瓶颈问题，那就不要去使用乐观锁，它增加了复杂度，也带来了额外的风险。

### 版本号（version）

版本号（记为version）：就是给数据增加一个版本标识，在数据库上就是表中增加一个version字段，每次更新把这个字段加1，读取数据的时候把version读出来，更新的时候比较version，如果还是开始读取的version就可以更新了，如果现在的version比老的version大，说明有其他事务更新了该数据，并增加了版本号，这时候得到一个无法更新的通知，用户自行根据这个通知来决定怎么处理，比如重新开始一遍。这里的关键是判断version和更新两个动作需要作为一个原子单元执行，否则在你判断可以更新以后正式更新之前有别的事务修改了version，这个时候你再去更新就可能会覆盖前一个事务做的更新，造成第二类丢失更新，所以你可以使用update … where … and version=”old version”这样的语句，根据返回结果是0还是非0来得到通知，如果是0说明更新没有成功，因为version被改了，如果返回非0说明更新成功。

### 时间戳（使用数据库服务器的时间戳）

时间戳（timestamp）：和版本号基本一样，只是**通过时间戳来判断**而已，注意时间戳要使用数据库服务器的时间戳不能是业务系统的时间。

### 待更新字段

待更新字段：和版本号方式相似，只是不增加额外字段，直接使用有效数据字段做版本控制信息，因为有时候我们可能无法改变旧系统的数据库表结构。假设有个待更新字段叫count,先去读取这个count,更新的时候去比较数据库中count的值是不是我期望的值（即开始读的值），如果是就把我修改的count的值更新到该字段，否则更新失败。java的基本类型的原子类型对象如AtomicInteger就是这种思想。

## 活锁与死锁的探究

并发控制会造成两种锁（这部分摘自https://www.cnblogs.com/ismallboy/p/5574006.html）

### 活锁

定义：指的是T1封锁了数据R，T2同时也请求封锁数据R，T3也请求封锁数据R，当T1释放了锁之后，T3会锁住R，T4也请求封锁R，则T2就会一直等待下去。

解决方法：采用**“先来先服务”**策略可以避免。

### 死锁

定义：就是我等你，你又等我，双方就会一直等待下去。比如：T1封锁了数据R1，正请求对R2封锁，而T2封住了R2,正请求封锁R1，这样就会导致死锁，死锁这种没有完全解决的方法，只能尽量预防。 

预防方法： 
1. 一次封锁法，指的是一次性把所需要的数据全部封锁住，但是这样会扩大了封锁的范围，降低系统的并发度； 
2. 顺序封锁法，指的是事先对数据对象指定一个封锁顺序，要对数据进行封锁，只能按照规定的顺序来封锁，但是这个一般不大可能的。

系统判定死锁的方法：

超时法：如果某个事物的等待时间超过指定时限，则判定为出现死锁；
等待图法：如果事务等待图中出现了回路，则判断出现了死锁。
对于解决死锁的方法，只能是撤销一个处理死锁代价最小的事务，释放此事务持有的所有锁，同时对撤销的事务所执行的数据修改操作必须加以恢复。

# 针对MyISAM和InnoDB引擎

## 总述

MySQL中不同的存储引擎支持不同的锁机制。比如MyISAM和MEMORY存储引擎采用的表级锁，BDB采用的是页面锁，也支持表级锁，InnoDB存储引擎既支持行级锁，**也支持表级锁，默认情况下采用行级锁**。

1. 行级锁：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高。

1. 表级锁：开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高，并发度最低。

1. 页级锁：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般。

仅从锁的角度来说：表级锁更适合于**以查询为主，只有少量按索引条件更新数据的应用**，如Web应用；而行级锁则更适合于**有大量按索引条件并发更新少量不同数据**，同时又有并发查询的应用，如一些在线事务处理（OLTP）系统。

### MyISAM

MyISAM只有表锁，其中又分为读锁和写锁。

前面得知：mysql的表锁有两种模式：表共享读锁（table read lock）和表独占写锁（table write lock）。（意向锁是解决行锁与表锁冲突，不在此引擎中）。

### InnoDB

1）支持事务
2）采用行级锁

一共三类：共享锁，排他锁，意向锁。其中意向锁分为意向共享锁和意向排他锁。