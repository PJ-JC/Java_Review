# 面试题

## 1.如何解决幻读、如何解决不可重复读？（蚂蚁）

**多版本并发控制（MVCC）（快照读/一致性读）**和**next-key-locking锁**

可以认为MVCC是行级锁的一个变种，但是它在很多情况下避免了加锁操作，因此开销更低。虽然实现机制有所不同，但大都实现了非阻塞的读操作，写操作也只锁定必要的行。

MVCC的实现，是通过**保存数据在某个时间点的快照来实现的**。也就是说，不管需要执行多长时间，每个事务看到的数据都是一致的。根据事务开始的时间不同，每个事务对同一张表，同一时刻看到的数据可能是不一样的。如果之前没有这方面的概念，这句话听起来就有点迷惑。熟悉了以后会发现，这句话其实还是很容易理解的。

前面说到不同存储引擎的MVCC实现是不同的，典型的有乐观（optimistic）并发控制控制和悲观（pessimistic）并发控制。

MVCC只在REPEATABLEREAD和READCOMMITTED两个隔离级别下工作。其他两个隔离级别都和MVCC不兼容(4)，因为READUNCOMMITTED总是读取最新的数据行，而不是符合当前事务版本的数据行。而SERIALIZABLE则会对所有读取的行都加锁。

### 总结：

1. 如果仅仅考虑数据内容发生变化来衡量不可重复读，那么只有在read committed隔离级别的快照读中才会出现不可重复读，如果考虑数据数量变化，那么在read committed隔离级别的快照读和当前读中都存在不可重复读现象；
1. read committed隔离级别下，快照读和当前读都会产生幻读现象；
1. repeatable read隔离级别下，只有快照读会产生幻读现象，当前读已经通过gap锁的引入消除了幻读现象。

https://www.cnblogs.com/wdy1184/p/10655180.html

## 2. 数据库并发读写会出现什么问题？（有赞）

脏读、不可重复读、幻读

1、脏读：脏读就是指当一个事务正在访问数据，并且对数据进行了修改，而这种修改还没有提交到数据库中，这时，另外一个事务也访问这个数据，然后使用了这个数据。
   例如：
 张三的工资为5000,事务A中把他的工资改为8000,但事务A尚未提交。
 与此同时，
   事务B正在读取张三的工资，读取到张三的工资为8000。
 随后，
   事务A发生异常，而回滚了事务。张三的工资又回滚为5000。
 最后，
   事务B读取到的张三工资为8000的数据即为脏数据，事务B做了一次脏读。  

   2、不可重复读：是指在一个事务内，多次读同一数据。在这个事务还没有结束时，另外一个事务也访问该同一数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改，那么第一个事务两次读到的的数据可能是不一样的。这样就发生了在一个事务内两次读到的数据是不一样的，因此称为是不可重复读。
   例如：
 在事务A中，读取到张三的工资为5000，操作没有完成，事务还没提交。
 与此同时，
   事务B把张三的工资改为8000，并提交了事务。
 随后，
   在事务A中，再次读取张三的工资，此时工资变为8000。**在一个事务中前后两次读取的结果并不致，导致了不可重复读。** 

   3、幻读：**是指当事务不是独立执行时发生的一种现象**，例如第一个事务对一个表中的数据进行了修改，这种修改涉及到表中的全部数据行。同时，第二个事务也修改这个表中的数据，这种修改是向表中插入一行新数据。那么，以后就会发生操作第一个事务的用户发现表中还有没有修改的数据行，就好象发生了幻觉一样。
   例如：
 目前工资为5000的员工有10人，事务A读取所有工资为5000的人数为10人。
 此时，
   事务B插入一条工资也为5000的记录。
 这是，事务A再次读取工资为5000的员工，记录为11人。此时产生了幻读。 

   4、提醒   
   不可重复读的重点是修改：（Update）  
 **同样的条件，你读取过的数据，再次读取出来发现值不一样了**
   幻读的重点在于新增或者删除：（Insert或Delete)  
 **同样的条件，第 1 次和第 2 次读出来的记录数不一样**

总结：

​		 脏读： 当前事务读到的数据是别的事务想要修改成为的但是没有修改成功的数据。

​        ②       不可重复读：A事务读取了B事务已经提交的数据，导致**两次读不一致**。当前事务先进行了一次数据读取，然后再次读取到的数据是别的事务修改成功的数据，导致两次读取到的数据不匹配，也就照应了不可重复读的语义。

​        ③       幻读：A事务读取了B事务新增的数据，幻象读和不可重复读是两个容易混淆的概念，前者是指读到了其它已经提交事务的新增数据，而后者是指读到了已经提交事务的更改数据（更改或删除）

​        ④       第一类丢失更新：A事务撤销时，把已经提交的B事务的更新数据覆盖了

  链接：https://www.nowcoder.com/questionTerminal/62c07c8fcb5c4f4cb2f237394503bd65?orderByHotValue=0&pos=58&mutiTagIds=606
来源：牛客网

## 3. 事务的理解（壹钱包）

事务：

事务是一组原子性sql查询语句，被当作一个工作单元。若mysql对改事务单元内的所有sql语句都正常的执行完，则事务操作视为成功，所有的sql语句才对数据生效，若sql中任意不能执行或出错则事务操作失败，所有对数据的操作则无效(通过回滚恢复数据)。事务有四个属性：

1、原子性：事务被认为不可分的一个工作单元，要么全部正常执行，要么全部不执行。

2、一致性：事务操作对数据库总是从一种一致性的状态转换成另外一种一致性状态。

3、隔离性：一个事务的操作结果**在内部一致，可见，而对除自己以外的事务是不可见的。**

4、永久性：事务在未提交前数据一般情况下可以回滚恢复数据，**一旦提交(commit)数据的改变则变成永久**(当然用update肯定还能修改)。

ps:MYSAM 引擎的数据库不支持事务，所以事务最好不要对混合引擎(如INNODB 、MYISAM)操作，若能正常运行且是你想要的最好，否则事务中对非支持事务表的操作是不能回滚恢复的。

读锁：

也叫共享锁、S锁，若事务T对数据对象A加上S锁，则事务T可以读A但不能修改A，其他事务只能再对A加S锁，而不能加X锁，直到T释放A上的S 锁。这保证了其他事务可以读A，但在T释放A上的S锁之前不能对A做任何修改。

写锁：

又称排他锁、X锁。若事务T对数据对象A加上X锁，事务T可以读A也可以修改A，其他事务不能再对A加任何锁，直到T释放A上的锁。这保证了其他事务在T释放A上的锁之前不能再读取和修改A。

表锁：操作对象是数据表。Mysql大多数锁策略都支持(常见mysql innodb)，是系统开销最低但并发性最低的一个锁策略。事务t对整个表加读锁，则其他事务可读不可写，若加写锁，则其他事务增删改都不行。

行级锁：操作对象是数据表中的一行。是MVCC技术用的比较多的，但在MYISAM用不了，行级锁用mysql的储存引擎实现而不是mysql服务器。但行级锁对系统开销较大，处理高并发较好。

MVCC：多版本并发控制(MVCC,Multiversion Currency Control)。一般情况下，事务性储存引擎不是只使用表锁，行加锁的处理数据，而是结合了MVCC机制，以处理更多的并发问题。Mvcc处理高并发能力最强，但系统开销比最大(较表锁、行级锁)，这是最求高并发付出的代价。

Autocommit：是mysql一个系统变量，默认情况下autocommit=1表示mysql把没一条sql语句自动的提交，而不用commit语句。所以，当要开启事务操作时，要把autocommit设为0，可以通过“set session autocommit=0; ”来设置

# 隔离性与隔离级别

你肯定会想到ACID（Atomicity、Consistency、Isolation、Durability，即原子性、一致性、隔离性、持久性），今天我们就来说说其中I，也就是“隔离性”。

当数据库上有多个事务同时执行的时候，就可能出现**脏读（dirty read）、不可重复读（non-repeatable read）、幻读（phantom read）**的问题，为了解决这些问题，就有了“隔离级别”的概念。

- **脏读（Dirty read）**: 当一个事务正在访问数据并且**对数据进行了修改**，**而这种修改还没有提交到数据库中**，这时另外一个事务也访问了这个数据，然后使用了这个数据。因为这个数据是还没有提交的数据，那么另外一个事务读到的这个数据是“脏数据”，依据“脏数据”所做的操作可能是不正确的。
- 丢失修改（Lost to modify）: 指在一个事务读取一个数据时，另外一个事务也访问了该数据，那么在第一个事务中修改了这个数据后，第二个事务也修改了这个数据。这样第一个事务内的修改结果就被丢失，因此称为丢失修改。	例如：事务1读取某表中的数据A=20，事务2也读取A=20，事务1修改A=A-1，事务2也修改A=A-1，最终结果A=19，事务1的修改被丢失。
- **不可重复读（Unrepeatableread）**: 指在一个事务内多次读同一数据。在这个事务还没有结束时，另一个事务也访问该数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改导致第一个事务两次读取的数据可能不太一样。这就发生了在**一个事务内两次读到的数据是不一样**的情况，因此称为不可重复读。
- **幻读（Phantom read）**: 幻读与不可重复读类似。它发生在一个事务（T1）读取了几行数据，接着另一个并发事务（T2）插入了一些数据时。在随后的查询中，第一个事务（T1）就会**发现多了一些原本不存在的记录，就好像发生了幻觉一样**，所以称为幻读。

在谈隔离级别之前，你首先要知道，你隔离得越严实，效率就会越低。

## 事务隔离级别

SQL 标准定义了四个隔离级别：

READ-UNCOMMITTED(读取未提交)： 最低的隔离级别，**允许读取尚未提交的数据变更**，可能会导致脏读、幻读或不可重复读。

READ-COMMITTED(读取已提交)： **允许读取并发事务已经提交的数据**，可以阻止脏读，但是幻读或不可重复读仍有可能发生。

REPEATABLE-READ(可重复读)： **对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改**，可以阻止脏读和不可重复读，但幻读仍有可能发生。

SERIALIZABLE(可串行化)： **最高的隔离级别，完全服从ACID的隔离级别。**所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。


| 隔离级别	            | 脏读	 | 不可重复读	 | 幻读 |
|------------------|-----|--------|----|
| READ-UNCOMMITTED | √   | √      | √  |
| READ-COMMITTED   | ×   | √      | √  |
| REPEATABLE-READ  | ×   | ×      | √  |
| SERIALIZABLE     | ×   | ×      | ×  |


