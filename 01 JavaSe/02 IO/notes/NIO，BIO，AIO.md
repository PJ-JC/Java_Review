# 面试题

## 1. Reactor 模型

一个线程 Thread **使用一个选择器 Selector 通过轮询的方式去监听多个通道 Channel 上的事件**，从而让一个线程就可以处理多个事件。

# 同步/异步、阻塞/非阻塞、并行/并发

（1）**同步：**当发出一个功能调用时，在没有得到结果之前，该**调用就不返回或停止执行后续操作。**

（2）**异步：**当一个异步过程调用发出后，调用者在没有得到结果之前，就可以继续执行后续操作，当这个调用完成后，一般**通过状态、通知和回调来通知调用者。**

（3）**阻塞：**调用结果返回之前，**当前线程会被挂起。**调用线程只有在得到结果之后才会返回。

（4）**非阻塞：**在不能立刻得到结果之前，**该调用不会阻塞当前线程，继续处理后续的操作。**

（5）**并发：**当系统只有一个CPU时，**操作系统只能把CPU运行时间划分成若干个时间段，再将时间段分配给各个线程执行**。

（6）**并行：**当系统有多个CPU时，可以存在当一个CPU执行一个线程时，另一个CPU可以执行另一个线程，两个线程互不抢占CPU资源，可以同时进行。

- 先来个例子理解一下概念，以银行取款为例：

	- 同步 ： **自己亲自**出马持银行卡到银行取钱（使用同步IO时，Java自己处理IO读写）。
	- 异步 ： **委托一小弟**拿银行卡到银行取钱，然后给你（使用异步IO时，Java将IO读写委托给OS处理，需要将数据缓冲区地址和大小传给OS(银行卡和密码)，OS需要支持异步IO操作API）。
	- 阻塞 ： ATM排队取款，你**只能等待**（使用阻塞IO时，Java调用会一直阻塞到读写完成才返回）。
	- 非阻塞 ： 柜台取款，取个号，然后坐在椅子上做其它事，等号广播会通知你办理，没到号你就不能去，你可以不断问大堂经理排到了没有，大堂经理如果说还没到你就不能去（使用非阻塞IO时，如果不能读写Java调用会马上返回，当IO事件分发器会通知可读写时再继续进行读写，不断循环直到读写完成）。可以干其他事，等待通知。
	
	烧水
	
	**BIO （Blocking I/O）：同步阻塞I/O模式。**
	
	**NIO （New I/O）：同步非阻塞模式。**
	
	**AIO （Asynchronous I/O）：异步非阻塞I/O模型。**
	
	那么，同步阻塞、同步非阻塞、异步非阻塞都是怎么回事呢？关于这部分内容也可以查看《[漫话：如何给女朋友解释什么是IO中的阻塞、非阻塞、同步、异步？](https://link.juejin.im?target=http%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzg3MjA4MTExMw%3D%3D%26mid%3D2247484751%26idx%3D1%26sn%3De9c24082baeeea4df363af0a788d7fc2%26chksm%3Dcef5f6f9f9827fef26458b6ea7d794e4fd10b2596f271e986da708e267e7957440bc56663340%26scene%3D21%23wechat_redirect)》。
	
	同步阻塞模式：这种模式下，我们的工作模式是先来到厨房，开始烧水，并坐在水壶面前一直等着水烧开。
	
	同步非阻塞模式：这种模式下，我们的工作模式是先来到厨房，开始烧水，但是我们不一直坐在水壶前面等，而是回到客厅看电视，然后每隔几分钟到厨房看一下水有没有烧开。
	
	异步非阻塞I/O模型：这种模式下，我们的工作模式是先来到厨房，开始烧水，我们不一一直坐在水壶前面等，也不隔一段时间去看一下，而是在客厅看电视，水壶上面有个开关，水烧开之后他会通知我。
	
	阻塞VS非阻塞：人是否坐在水壶前面一直等。
	
	同步VS异步：水壶是不是在水烧开之后主动通知人。
	
	
	作者：漫话编程链接：https://juejin.im/post/5d19820c6fb9a07ea42094e2
## 总结

阻塞/非阻塞是**针对某一个事件（线程/进程）**来说的。同步/异步是**针对多个事件（线程/进程）**来说的。阻塞调用和同步调用不同，对于同步调用来说，很多时候当前线程可能还是激活的，只是从逻辑上当前调用没有返回而已，这个线程可能也会处理其他的消息。  

并行是指多个任务同时在跑，是真正地同时运行。并发通常是指多个任务交替使用CPU，**同一时刻还是只有一个任务在跑**。

# Java中的NIO，BIO，AIO分别是什么

- 同步阻塞IO（BIO）：用户进程发起一个IO操作以后，**必须等待IO操作的真正完成后，才能继续运行**；

- 同步非阻塞IO（NIO）：用户进程发起一个IO操作以后，**可做其它事情，但用户进程需要经常询问IO操作是否完成，这样造成不必要的CPU资源浪费**；

- 异步非阻塞IO（AIO）：用户进程发起一个IO操作然后，**立即返回，等IO操作真正的完成以后，应用程序会得到IO操作完成的通知**。类比Future模式。

## 1 、同步阻塞IO（BIO）

原理：同步阻塞IO (blocking IO)，服务器实现模式为**一个连接一个线程**，即客户端有连接请求时服务器端就需要**启动一个线程进行处理**，如果这个连接不做任何事情会造成不必要的线程开销，当然可以通过线程池机制改善。

具体应用：

- Stream类流式主要用于操作二进制文件,

  例如 InputStream/OutputStream,FileInputStream/FileOutputStream,

GzipOutputStream...

- Writer/Reader 主要用于操作文本类操作

 例如 FileReader/FileWriter等

- Buffer类, 带缓冲类的实现可以避免频繁的IO磁盘读写,

 例如BufferdWriter/BufferdReader,BufferedOutputStream/BufferedInputStream

*注意事项*

（1）使用缓冲区类一定要加flush

（2）使用BIO需要显式关闭, 常使用try-finally进行关闭

## 2、同步非阻塞IO(NIO)

原理：服务器实现模式为一个请求一个线程，即客户端发送的连接请求都会注册到多路复用器上，多路复用器轮询到连接有I/O请求时才启动一个线程进行处理。用户进程也需要时不时的询问IO操作是否就绪，这就要求用户进程不停的去询问。

主要组成：

- **Channel(通道)**

  国内大多翻译成“通道”。Channel和IO中的Stream相似，属于同一级别。Stream是单向的，例如InputStream, OutputStream，而Channel是双向的，既可以用来进行读操作，又可以用来进行写操作。

实现：FileChannel、DatagramChannel、SocketChannel、ServerSocketChannel

- **Buffer(缓冲区)**

  一个Buffer对象是固定数量的数据的容器。其作用是一个存储器或分段运输区,在这

里数据可被存储并在之后用于检索。

实现：CharBuffer、 DoubleBuffer、MappedByteBuffer、HeapByteBuffer 等

- **Selector(选择区)**

Selector会不断轮询注册在其上的Channel，如果某个Channel上面发生读或者写事件，这个Channel就处于就绪状态，会被Selector轮询出来，然后通过SelectionKey

可以获取就绪Channel的集合，进行后续的I/O操作。

属性：选择器(Selector)、可选择通道(SelectableChannel)、选择键(SelectionKey)

## 3 、异步非阻塞IO（AIO）

AIO是对JDK1.4中提出的同步非阻塞I/O(NIO)的进一步增强，常常也被称为NIO.2

原理：服务器实现模式为**一个有效请求一个线程**，客户端的I/O请求都是由OS先完成了再通知服务器应用去启动线程进行处理。此时用户进程只需要对数据进行处理就好了，不需要进行实际的IO读写操作，因为真正的IO读取或者写入操作已经由内核完成了。

主要实现：

在不同的操作系统上, AIO由不同的技术实现

JAVA AIO框架在windows下使用windows IOCP技术

JAVA AIO框架在Linux下使用epoll多路复用IO技术模拟异步IO

主要组成（JDK1.7）

AsynchronousFileChannel: 用于文件异步读写；

AsynchronousSocketChannel: 客户端异步socket；

AsynchronousServerSocketChannel: 服务器异步socket。

# I/O多路复用模式：Reactor和Proactor

I/O 多路复用机制（I/O multiplexing mechanisms）依赖于一个事件多路分用器（Event demultiplexor）。常见的事件多路分用器包括：Linux 的 EPOLL 和 Windows 的IOCP，事件多路分用器相关的两个设计模式为 Proactor 和 Reactor。

# BIO，NIO，AIO区别

- BIO（同步阻塞）：客户端和服务器连接需要三次握手，使用简单，但吞吐量小

- NIO（同步非阻塞）：客户端与服务器通过Channel连接，采用多路复用器轮询注册的Channel。提高吞吐量和可靠性。

- AIO（异步非阻塞）：NIO的升级版，采用异步通道实现异步通信，其read和write方法均是异步方法。

# BIO、NIO及AIO的应用场景

（1）BIO方式适用于连接数目比较小且固定的架构，这种方式对服务器资源要求比较高，

并发局限于应用中，JDK1.4以前的唯一选择，但程序直观简单易理解。

（2）NIO方式适用于连接数目多且连接比较短（轻操作）的架构，比如聊天服务器，

并发局限于应用中，编程比较复杂，JDK1.4开始支持。

（3）AIO方式使用于连接数目多且连接比较长（重操作）的架构，比如相册服务器，

充分调用OS参与并发操作，编程比较复杂，JDK7开始支持。
	