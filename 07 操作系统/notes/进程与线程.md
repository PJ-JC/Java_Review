# 面试题

## 1.线程和进程的区别？

- 拥有资源：进程是资源分配的基本单位，而线程**不拥有资源**。程序运行时系统就会创建一个进程，并为它分配资源，然后把该进程放入进程就绪队列，进程调度器选中它的时候就会为它分配CPU时间，程序开始真正运行。
- 调度：线程是**独立调度的基本单位**，在同一进程中，**线程的切换不会引起进程切换，**从一个进程内的线程切换到另一个进程中的线程时，会引起进程切换。切换线程的消费远比进程小的多。
- 通信方面：进程间通信需要**进程同步和互斥手段**的辅助，线程间可以通过**直接读/写同一进程中的数据段**来通信。
- 系统开销：由于**创建或撤销进程时，系统都要为之分配或回收资源**，如内存空间、I/O 设备等，所付出的**开销远大于创建或撤销线程时的开销**。类似地，在进行进程切换时，涉及当前执行进程 CPU 环境的保存及新调度进程 CPU 环境的设置，而线程切换时只需保存和设置少量寄存器内容，**开销很小**。

## 2.代码执行单元是？

线程

## 3.是线程还是进程申请资源

进程

## 4. 进程之间的通信方式

### 1、管道

我们来看一条 Linux 的语句

```
netstat -tulnp | grep 8080
```

学过 Linux 命名的估计都懂这条语句的含义，其中”|“是**管道**的意思，它的作用就是把前一条命令的输出作为后一条命令的输入。在这里就是把 netstat -tulnp 的输出结果作为 grep 8080 这条命令的输入。如果两个进程要进行通信的话，就可以用这种**管道**来进行通信了，并且我们可以知道这条**竖线**是没有名字的，所以我们把这种通信方式称之为**匿名管道**。

并且这种通信方式是**单向**的，只能把第一个命令的输出作为第二个命令的输入，如果进程之间想要互相通信的话，那么需要创建两个管道。

居然有匿名管道，那也意味着有**命名**管道，下面我们来创建一个命名管道。

```
mkfifo  test
```

这条命令创建了一个名字为 test 的命名管道。

接下来我们用一个进程向这个管道里面写数据，然后有另外一个进程把里面的数据读出来。

```
echo "this is a pipe" > test   // 写数据
```

这个时候管道的内容没有被读出的话，那么这个命令就会一直停在这里，只有当另外一个进程把 test 里面的内容读出来的时候这条命令才会结束。接下来我们用另外一个进程来读取

```
cat < test  // 读数据
```

我们可以看到，test 里面的数据被读取出来了。上一条命令也执行结束了。

从上面的例子可以看出，管道的通知机制类似于**缓存**，就像一个进程把数据放在某个缓存区域，然后等着另外一个进程去拿，并且是管道是**单向传输的。**

这种通信方式有什么缺点呢？显然，这种通信方式**效率低下**，你看，a 进程给 b 进程传输数据，只能等待 b 进程取了数据之后 a 进程才能返回。

所以管道不适合频繁通信的进程。当然，他也有它的优点，例如比较简单，能够保证我们的数据已经真的被其他进程拿走了。我们平时用 Linux 的时候，也算是经常用。

### 2、消息队列

那我们能不能把进程的数据放在某个内存之后就马上让进程返回呢？无需等待其他进程来取就返回呢？

答是可以的，我们可以用**消息队列**的通信模式来解决这个问题，例如 a 进程要给 b 进程发送消息，只需要把消息放在对应的消息队列里就行了，b 进程需要的时候再去对应的
消息队列里取出来。同理，b 进程要个 a 进程发送消息也是一样。这种通信方式也类似于**缓存**吧。

这种通信方式有缺点吗？答是有的，如果 a 进程发送的数据占的内存比较大，并且两个进程之间的通信特别频繁的话，消息队列模型就不大适合了。因为 a 发送的数据很大的话，意味**发送消息（拷贝）**这个过程需要花很多时间来读内存。

哪有没有什么解决方案呢？答是有的，请继续往下看。

### 3、共享内存

**共享内存**这个通信方式就可以很好着解决**拷贝**所消耗的时间了。

这个可能有人会问了，每个进程不是有自己的独立内存吗？两个进程怎么就可以共享一块内存了？

我们都知道，系统加载一个进程的时候，分配给进程的内存并不是**实际物理内存**，而是**虚拟内存空间**。那么我们可以让两个进程各自拿出一块虚拟地址空间来，然后映射到相同的物理内存中，这样，两个进程虽然有着独立的虚拟内存空间，但有一部分却是映射到相同的物理内存，这就完成了**内存共享**机制了。

### 4、信号量

共享内存最大的问题是什么？没错，就是多进程竞争内存的问题，就像类似于我们平时说的**线程安全**问题。如何解决这个问题？这个时候我们的**信号量**就上场了。

信号量的本质就是一个计数器，用来实现进程之间的互斥与同步。例如信号量的初始值是 1，然后 a 进程来访问**内存1**的时候，我们就把**信号量的值设为 0**，然后进程b 也要来访问**内存1**的时候，看到信号量的值为 0 就知道已经有进程在访问**内存1**了，这个时候进程 b 就会访问不了**内存1**。所以说，信号量也是进程之间的一种通信方式。

### 5、Socket

上面我们说的共享内存、管道、信号量、消息队列，他们都是多个进程在一台主机之间的通信，那两个相隔几千里的进程能够进行通信吗？

答是必须的，这个时候 Socket 这家伙就派上用场了，例如我们平时通过浏览器发起一个 http 请求，然后服务器给你返回对应的数据，这种就是采用 Socket 的通信方式了。

## 5. 为什么线程比进程资源调度快（百度）

线程是**独立调度的基本单位**，在同一进程中，**线程的切换不会引起进程切换，**从一个进程内的线程切换到另一个进程中的线程时，会引起进程切换。切换线程的消费远比进程小的多。

# 进程与线程

## 1.进程

进程是**资源分配**的基本单位，用来管理资源（例如：内存，文件，网络等资源）。

## 2.线程

线程是**独立调度**的基本单位。同一个进程中的多个线程之间可以并发执行，它们共享进程资源。

## 3.区别

- 拥有资源：进程是资源分配的基本单位，而线程**不拥有资源**。

- 调度：线程是**独立调度的基本单位**，在同一进程中，线程的切换不会引起进程切换，从一个进程内的线程切换到另一个进程中的线程时，会引起进程切换。

- 通信方面：进程间通信需要**进程同步和互斥手段**的辅助，线程间可以通过**直接读/写同一进程中的数据段**来通信。

- 系统开销：由于**创建或撤销进程时，系统都要为之分配或回收资源**，如内存空间、I/O 设备等，所付出的**开销远大于创建或撤销线程时的开销**。类似地，在进行进程切换时，涉及当前执行进程 CPU 环境的保存及新调度进程 CPU 环境的设置，而线程切换时只需保存和设置少量寄存器内容，**开销很小**。

# 进程状态的切换

![](https://raw.githubusercontent.com/wuqifan1098/picBed/master/%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81.png)

- 就绪状态（ready）：等待被调度

- 运行状态（running）

- 阻塞状态（waiting）：等待资源

应该注意以下内容：

- 只有就绪态和运行态可以相互转换，其它的都是单向转换。就绪状态的进程通过调度算法从而获得 CPU 时间，转为运行状态；

- 而运行状态的进程，在分配给它的 CPU 时间片用完之后就会转为就绪状态，等待下一次调度。阻塞状态是缺少需要的资源从而由运行状态转换而来，但是该资源不包括 CPU 时间，缺少 CPU 时间会从运行态转换为就绪态；

- 进程只能自己阻塞自己，因为只有进程自身才知道何时需要等待某种事件的发生。

# 进程间通信的机制有哪些？

## 1. 共享存储

![](https://raw.githubusercontent.com/wuqifan1098/picBed/master/%E5%85%B1%E4%BA%AB%E5%AD%98%E5%82%A8.png)

### 1.1 基于数据结构的共享

- 速度慢、限制多，是**低级通信**方式

### 1.2 基于存储区的共享

- 速度快，是**高级通信**方式

## 2.管道通信

![](https://raw.githubusercontent.com/wuqifan1098/picBed/master/%E7%AE%A1%E9%81%93%E9%80%9A%E4%BF%A1.png)

- 只支持半双工通信（单向传输）

- 只能在父子进程中使用

## 3.消息传递

![](https://raw.githubusercontent.com/wuqifan1098/picBed/master/%E6%B6%88%E6%81%AF%E4%BC%A0%E9%80%92.png)

- 直接通信
- 间接通信

# 进程间的调度算法

什么叫“多任务”呢？简单地说，就是操作系统可以同时运行多个任务。打个比方，你一边在用浏览器上网，一边在听MP3，一边在用Word赶作业，这就是多任务，至少同时有3个任务正在运行。还有很多任务悄悄地在后台同时运行着，只是桌面上没有显示而已。

现在，多核CPU已经非常普及了，但是，即使过去的单核CPU，也可以执行多任务。由于CPU执行代码都是顺序执行的，那么，单核CPU是怎么执行多任务的呢？

答案就是操作系统轮流让各个任务交替执行，任务1执行0.01秒，切换到任务2，任务2执行0.01秒，再切换到任务3，执行0.01秒……这样反复执行下去。表面上看，每个任务都是交替执行的，但是，由于CPU的执行速度实在是太快了，我们感觉就像所有任务都在同时执行一样。

真正的并行执行多任务只能在多核CPU上实现，但是，由于任务数量远远多于CPU的核心数量，所以，操作系统也会自动把很多任务轮流调度到每个核心上执行。

对于操作系统来说，一个任务就是一个进程（Process），比如打开一个浏览器就是启动一个浏览器进程，打开一个记事本就启动了一个记事本进程，打开两个记事本就启动了两个记事本进程，打开一个Word就启动了一个Word进程。

有些进程还不止同时干一件事，比如Word，它可以同时进行打字、拼写检查、打印等事情。在一个进程内部，要同时干多件事，就需要同时运行多个“子任务”，我们把进程内的这些“子任务”称为线程（Thread）。

由于每个进程至少要干一件事，所以，一个进程至少有一个线程。当然，像Word这种复杂的进程可以有多个线程，多个线程可以同时执行，多线程的执行方式和多进程是一样的，也是由操作系统在多个线程之间快速切换，让每个线程都短暂地交替运行，看起来就像同时执行一样。当然，真正地同时执行多线程需要多核CPU才可能实现。

## 1. 批处理系统中的调度

### 1.1 先来先服务

first-come first-serverd（FCFS）。

调度最先进入就绪队列的作业。

有利于长作业，但不利于短作业，因为短作业必须一直等待前面的长作业执行完毕才能执行，而长作业又需要执行很长时间，造成了短作业等待时间过长。

### 1.2 短作业优先

shortest job first（SJF）。

调度估计**运行时间最短的作业**。

长作业有可能会饿死，处于一直等待短作业执行完毕的状态。如果一直有短作业到来，那么长作业永远得不到调度。

### 1.3 最短剩余时间优先

shortest remaining time next（SRTN）。

## 2. 交互式系统中的调度

### 2.1 优先权优先

除了可以手动赋予优先权之外，还可以把响应比作为优先权，这种调度方式叫做高响应比优先调度算法。

响应比 = (等待时间 + 要求服务时间) / 要求服务时间 = 响应时间 / 要求服务时间

这种调度算法主要是为了解决 SJF 中长作业可能会饿死的问题，因为随着等待时间的增长，响应比也会越来越高。

### 2.2  时间片轮转

将所有就绪进程按 FCFS 的原则排成一个队列，每次调度时，把 CPU 分配给队首进程，该进程可以执行一个时间片。当时间片用完时，由计时器发出时钟中断，调度程序便停止该进程的执行，并将它送往就绪队列的末尾，同时继续把 CPU 分配给队首的进程。

时间片轮转算法的效率和时间片的大小有很大关系。因为每次进程切换都要保存进程的信息并且载入新进程的信息，如果时间片太小，进程切换太频繁，在进程切换上就会花过多时间。

### 2.3  多级反馈队列

1. 设置多个就绪队列，并为各个队列赋予不同的优先级。第一个队列的优先级最高，第二个队列次之，其余各队列的优先权逐个降低。该算法赋予各个队列中进程执行时间片的大小也各不相同，在优先权越高的队列中，为每个进程所规定的执行时间片就越小。

2. 当一个新进程进入内存后，首先将它放入第一队列的末尾，按 FCFS 原则排队等待调度。当轮到该进程执行时，如它能在该时间片内完成，便可准备撤离系统；如果它在一个时间片结束时尚未完成，调度程序便将该进程转入下一个队列的队尾。

3. 仅当前 i -1 个队列均空时，才会调度第 i 个队列中的进程。

优点：实时性好，同时适合运行短作业和长作业。

![](https://raw.githubusercontent.com/wuqifan1098/picBed/master/%E5%A4%9A%E7%BA%A7%E5%8F%8D%E9%A6%88%E9%98%9F%E5%88%97.png)

### 2.4  短进程优先

## 3. 实时系统中的调度

实时系统要一个服务请求在一个确定时间内得到响应。

分为硬实时和软实时，前者必须满足绝对的截止时间，后者可以容忍一定的超时。

# 进程同步

## 1.临界区

对临界资源进行访问的那段代码称为临界区。

为了互斥访问临界资源，每个进程在进入临界区之前，需要先进行检查。

## 2.同步与互斥

- 同步：多个进程按一定顺序执行；
- 互斥：多个进程在同一时刻只有一个进程能进入临界区。

## 3.信号量

信号量用于限制对临界资源的访问数量，保证了消费数量不会大于生产数量。

触发重置事件对象，那么等待的所有线程中将只有一个线程能唤醒，并同时自动的将此事件对象设置为无信号的；它能够确保一个线程独占对一个资源的访问。和互斥量的区别在于多了一个前置条件判定。

## 4.管程

# 进程通信

## 1. 管道

它具有以下限制：

- 只支持半双工通信（单向交替传输）；

- 只能在父子进程中使用。

## 2. FIFO

  也称为命名管道，去除了管道只能在父子进程中使用的限制。

## 3. 消息队列

相比于 FIFO，消息队列具有以下优点：

- 消息队列可以独立于读写进程存在，从而避免了 FIFO 中同步管道的打开和关闭时可能产生的困难；
- 避免了 FIFO 的同步阻塞问题，不需要进程自己提供同步方法；
- 读进程可以根据消息类型有选择地接收消息，而不像 FIFO 那样只能默认地接收。

## 4. 信号量

它是一个计数器，用于为多个进程提供对共享数据对象的访问。

## 5. 共享存储

允许多个进程共享一个给定的存储区。因为数据不需要在进程之间复制，所以这是最快的一种 IPC。

需要使用信号量用来同步对共享存储的访问。

多个进程可以将同一个文件映射到它们的地址空间从而实现共享内存。另外 XSI 共享内存不是使用文件，而是使用内存的匿名段。

## 6. 套接字

与其它通信机制不同的是，它可用于不同机器间的进程通信。

参考

[https://cyc2018.github.io/CS-Notes/#/notes/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%20-%20%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86?id=_1-%E7%AE%A1%E9%81%93](https://cyc2018.github.io/CS-Notes/#/notes/计算机操作系统 - 进程管理?id=_1-管道)




