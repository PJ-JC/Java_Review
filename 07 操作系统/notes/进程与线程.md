# 面试题

## 1.线程和进程的区别？

线程是处理调度的基本单位，进程是资源分配的基本单位。

一般线程不拥有系统资源，但可以访问**隶属进程**的资源。

创建、撤销一个新线程系统开销小。两个线程间的**切换系统开销小**。

## 2.代码执行单元是？

线程

## 3.是线程还是进程申请资源

进程

# 进程与线程

## 1.进程

进程是**资源分配**的基本单位，用来管理资源（例如：内存，文件，网络等资源）。

## 2.线程

线程是**独立调度**的基本单位。同一个进程中的多个线程之间可以并发执行，它们共享进程资源。

## 3.区别

- 拥有资源：进程是资源分配的基本单位，而线程**不拥有资源**。

- 调度：线程是**独立调度的基本单位**，在同一进程中，线程的切换不会引起进程切换，从一个进程内的线程切换到另一个进程中的线程时，会引起进程切换。

- 通信方面：进程间通信需要**进程同步和互斥手段**的辅助，线程间可以通过**直接读/写同一进程中的数据段**来通信。

- 系统开销：由于创建或撤销进程时，系统都要为之分配或回收资源，如内存空间、I/O 设备等，所付出的**开销远大于创建或撤销线程时的开销**。类似地，在进行进程切换时，涉及当前执行进程 CPU 环境的保存及新调度进程 CPU 环境的设置，而线程切换时只需保存和设置少量寄存器内容，**开销很小**。

# 进程状态的切换

![](https://raw.githubusercontent.com/wuqifan1098/picBed/master/%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81.png)

- 就绪状态（ready）：等待被调度

- 运行状态（running）

- 阻塞状态（waiting）：等待资源

应该注意以下内容：

- 只有就绪态和运行态可以相互转换，其它的都是单向转换。就绪状态的进程通过调度算法从而获得 CPU 时间，转为运行状态；

- 而运行状态的进程，在分配给它的 CPU 时间片用完之后就会转为就绪状态，等待下一次调度。阻塞状态是缺少需要的资源从而由运行状态转换而来，但是该资源不包括 CPU 时间，缺少 CPU 时间会从运行态转换为就绪态；

- 进程只能自己阻塞自己，因为只有进程自身才知道何时需要等待某种事件的发生。

# 进程间通信的机制有哪些？

## 1. 共享存储

![](https://raw.githubusercontent.com/wuqifan1098/picBed/master/%E5%85%B1%E4%BA%AB%E5%AD%98%E5%82%A8.png)

### 1.1 基于数据结构的共享

- 速度慢、限制多，是**低级通信**方式

### 1.2 基于存储区的共享

- 速度快，是**高级通信**方式

## 2.管道通信

![](https://raw.githubusercontent.com/wuqifan1098/picBed/master/%E7%AE%A1%E9%81%93%E9%80%9A%E4%BF%A1.png)

- 只支持半双工通信（单向传输）

- 只能在父子进程中使用

## 3.消息传递

![](https://raw.githubusercontent.com/wuqifan1098/picBed/master/%E6%B6%88%E6%81%AF%E4%BC%A0%E9%80%92.png)

- 直接通信
- 间接通信

# 进程间的调度算法

## 1. 批处理系统中的调度

### 1.1 先来先服务

first-come first-serverd（FCFS）。

调度最先进入就绪队列的作业。

有利于长作业，但不利于短作业，因为短作业必须一直等待前面的长作业执行完毕才能执行，而长作业又需要执行很长时间，造成了短作业等待时间过长。

### 1.2 短作业优先

shortest job first（SJF）。

调度估计运行时间最短的作业。

长作业有可能会饿死，处于一直等待短作业执行完毕的状态。如果一直有短作业到来，那么长作业永远得不到调度。

### 1.3 最短剩余时间优先

shortest remaining time next（SRTN）。

## 2. 交互式系统中的调度

### 2.1 优先权优先

除了可以手动赋予优先权之外，还可以把响应比作为优先权，这种调度方式叫做高响应比优先调度算法。

响应比 = (等待时间 + 要求服务时间) / 要求服务时间 = 响应时间 / 要求服务时间

这种调度算法主要是为了解决 SJF 中长作业可能会饿死的问题，因为随着等待时间的增长，响应比也会越来越高。

### 2.2  时间片轮转

将所有就绪进程按 FCFS 的原则排成一个队列，每次调度时，把 CPU 分配给队首进程，该进程可以执行一个时间片。当时间片用完时，由计时器发出时钟中断，调度程序便停止该进程的执行，并将它送往就绪队列的末尾，同时继续把 CPU 分配给队首的进程。

时间片轮转算法的效率和时间片的大小有很大关系。因为每次进程切换都要保存进程的信息并且载入新进程的信息，如果时间片太小，进程切换太频繁，在进程切换上就会花过多时间。

### 2.3  多级反馈队列

1. 设置多个就绪队列，并为各个队列赋予不同的优先级。第一个队列的优先级最高，第二个队列次之，其余各队列的优先权逐个降低。该算法赋予各个队列中进程执行时间片的大小也各不相同，在优先权越高的队列中，为每个进程所规定的执行时间片就越小。

2. 当一个新进程进入内存后，首先将它放入第一队列的末尾，按 FCFS 原则排队等待调度。当轮到该进程执行时，如它能在该时间片内完成，便可准备撤离系统；如果它在一个时间片结束时尚未完成，调度程序便将该进程转入下一个队列的队尾。

3. 仅当前 i -1 个队列均空时，才会调度第 i 个队列中的进程。

优点：实时性好，同时适合运行短作业和长作业。

![](https://raw.githubusercontent.com/wuqifan1098/picBed/master/%E5%A4%9A%E7%BA%A7%E5%8F%8D%E9%A6%88%E9%98%9F%E5%88%97.png)

### 2.4  短进程优先

## 3. 实时系统中的调度

实时系统要一个服务请求在一个确定时间内得到响应。

分为硬实时和软实时，前者必须满足绝对的截止时间，后者可以容忍一定的超时。

# 进程同步

## 1.临界区

对临界资源进行访问的那段代码称为临界区。

为了互斥访问临界资源，每个进程在进入临界区之前，需要先进行检查。

## 2.同步与互斥

- 同步：多个进程按一定顺序执行；
- 互斥：多个进程在同一时刻只有一个进程能进入临界区。

## 3.信号量

信号量用于限制对临界资源的访问数量，保证了消费数量不会大于生产数量。

触发重置事件对象，那么等待的所有线程中将只有一个线程能唤醒，并同时自动的将此事件对象设置为无信号的；它能够确保一个线程独占对一个资源的访问。和互斥量的区别在于多了一个前置条件判定。

## 4.管程

# 进程通信

## 1. 管道

它具有以下限制：

- 只支持半双工通信（单向交替传输）；

- 只能在父子进程中使用。

## 2. FIFO

  也称为命名管道，去除了管道只能在父子进程中使用的限制。

## 3. 消息队列

相比于 FIFO，消息队列具有以下优点：

- 消息队列可以独立于读写进程存在，从而避免了 FIFO 中同步管道的打开和关闭时可能产生的困难；
- 避免了 FIFO 的同步阻塞问题，不需要进程自己提供同步方法；
- 读进程可以根据消息类型有选择地接收消息，而不像 FIFO 那样只能默认地接收。

## 4. 信号量

它是一个计数器，用于为多个进程提供对共享数据对象的访问。

## 5. 共享存储

允许多个进程共享一个给定的存储区。因为数据不需要在进程之间复制，所以这是最快的一种 IPC。

需要使用信号量用来同步对共享存储的访问。

多个进程可以将同一个文件映射到它们的地址空间从而实现共享内存。另外 XSI 共享内存不是使用文件，而是使用内存的匿名段。

## 6. 套接字

与其它通信机制不同的是，它可用于不同机器间的进程通信。

参考

[https://cyc2018.github.io/CS-Notes/#/notes/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%20-%20%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86?id=_1-%E7%AE%A1%E9%81%93](https://cyc2018.github.io/CS-Notes/#/notes/计算机操作系统 - 进程管理?id=_1-管道)




