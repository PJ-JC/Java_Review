# Hashmap

## 1. 如何减少hash碰撞

1.7 经过了四次Hash扰动

1.8 高16位和低16位异或，只做一次16位右移 异或

## 2.位运算的好处

**位运算(&)效率要比代替取模运算(%)高很多，主要原因是位运算直接对内存数据进行操作，不需要转成十进制，因此处理速度非常快。**

## 3.解决hash碰撞

1.7采用的是链地址法，会使HashMap的性能从O(1)降到O(N)。

1.8使用红黑树，将最差性能从O(N)提高到O(logn)

## 4. hashcode的作用

用于查找使用的

## 5. 为什么要重写hashcode和equals

规定相等的对象必须拥有相等的散列值、

如果equals返回true，但hashcode不相同，用key去查询hashmap的时候就会返回null

https://juejin.im/post/5d50c1826fb9a06b1777a795

# 多线程

## 1. Futuretask 怎么返回计算值的  线程怎么拿到另一个线程的计算结果

### Future

我们假设通过Executors工厂方法构建一个线程池es ，es要执行某个任务有两种方式，一种是执行 es.execute(runnable) ,这种情况是没有返回值的； **另外一种情况是执行 es.submit(runnale)或者 es.submit(callable) ,这种情况会返回一个Future的对象，然后调用Future的get()来获取返回值。**

Future是一个接口，他提供给了我们方法来检测当前的任务是否已经结束，还可以等待任务结束并且拿到一个结果，通过调用Future的get（）方法可以当任务结束后返回一个结果值，如果工作没有结束，则会阻塞当前线程，直到任务执行完毕，我们可以通过调用cancel（）方法来停止一个任务，如果任务已经停止，则cancel（）方法会返回true；如果任务已经完成或者已经停止了或者这个任务无法停止，则cancel（）会返回一个false。当一个任务被成功停止后，他无法再次执行。isDone（）和isCancel（）方法可以判断当前工作是否完成和是否取消。

### FutureTask

```java
public class FutureTask<V> implements RunnableFuture<V>
```

FutureTask实现了RunnableFuture的接口，既然我们知道最终返回的是一个FutureTask对象ftask，而且我们可以通过ftask.get()可以的来得到execute(task)的返回值。	

首先Runnable的run()是**没有返回值的**，所以当es.submit()的参数只有一个Runnable对象的时候，通过ftask.get()得到的也是一个null值，**当参数还有一个result的时候，就返回这个result**；如果参数是一个Callable的对象的时候，Callable的call()是有返回值的，同时这个call()方法会在转换的Runable对象ftask的run()方法中被调用，然后将它的返回值赋值给一个全局变量，最后在ftask的get()方法中得到这个值。

将Runnable对象转为RunnableFuture的方法：

```java
protected <T> RunnableFuture<T> newTaskFor(Runnable runnable, T value) {
    return new FutureTask<T>(runnable, value);
}
public FutureTask(Runnable runnable, V result) {
    this.callable = Executors.callable(runnable, result);
    this.state = NEW;       // ensure visibility of callable
}
```
Executors::callable()

```java
    public static <T> Callable<T> callable(Runnable task, T result) {
        if (task == null)
            throw new NullPointerException();
        return new RunnableAdapter<T>(task, result);
    }
```

Executors的内部类RunnableAdapter

```java
    static final class RunnableAdapter<T> implements Callable<T> {
        final Runnable task;
        final T result;
        RunnableAdapter(Runnable task, T result) {
            this.task = task;
            this.result = result;
        }
        public T call() {
            task.run();
            return result;
        }
    }
```

将Callable对象转为RunnableFuture的方法：

```java
protected <T> RunnableFuture<T> newTaskFor(Callable<T> callable) {
    return new FutureTask<T>(callable);
}
public FutureTask(Callable<V> callable) {
    if (callable == null)
        throw new NullPointerException();
    this.callable = callable;
    this.state = NEW;       // ensure visibility of callable
```

接下来我们来看execute(runnbale)的执行过程：

execute(runnable)最终的实现是在ThreadPoolExecutor，基本上所有的线程池都是通过ThreadPoolExecutor的构造方法传入不同的参数来构造的。

ThreadPoolExecutor::executor(runnable) :

```java
    public void execute(Runnable command) {
        if (command == null)
            throw new NullPointerException();
 
        int c = ctl.get();
        if (workerCountOf(c) < corePoolSize) {
            if (addWorker(command, true))
                return;
            c = ctl.get();
        }
        if (isRunning(c) && workQueue.offer(command)) {
            int recheck = ctl.get();
            if (! isRunning(recheck) && remove(command))
                reject(command);
            else if (workerCountOf(recheck) == 0)
                addWorker(null, false);
        }
        else if (!addWorker(command, false))
            reject(command);
    }
```

http://beautyboss.farbox.com/post/study/shen-ru-xue-xi-futuretask

https://blog.csdn.net/wei_lei/article/details/74262818

https://juejin.im/post/5a77e5716fb9a0635865555b

# JVM

## 1. Metaspace讲讲

java8的时候去除PermGen，将其中的方法区移到non-heap中的Metaspace

Metaspace与PermGen之间最大的区别在于：Metaspace并不在虚拟机中，而是使用本地内存。

将**常量池从PermGen剥离到heap中**，将**元数据从PermGen剥离到元数据区**，去除PermGen的好处如下：

- 将字符串常量池从PermGen分离出来，与类元数据分开，提升类元数据的独立性
- 将元数据从PermGen剥离出来到Metaspace，可以**提升对元数据的管理同时提升GC效率**。

## 2. 逃逸分析

# MySQL

## 1. 为什么MySQL的索引要使用B+树而不是其它树形结构?比如B树？

因为B树不管叶子节点还是非叶子节点，都会保存数据，这样导致在非叶子节点中能保存的指针数量变少（有些资料也称为扇出）

指针少的情况下要保存大量数据，**只能增加树的高度，导致IO操作变多，查询性能变低；**

## 2.explain

**执行计划字段分析**

 id列 

 id列的编号是 select 的序列号，有几个 select 就有几个id，并且id的顺序是按 select 出现的顺序增长的。MySQL将 select 查询分为**简单查询(SIMPLE)和复杂查询(PRIMARY)。**复杂查询分为三类：简单子查询、派生表（from语句中的子查询）、union 查询。**id列越大执行优先级越高，id相同则从上往下执行，id为NULL最后执行。**如下：

```mysql
EXPLAIN EXTENDED SELECT *,(select classes_name from t_classes) classes_name FROM t_student WHERE classes_id = 1;
+----+-------------+-----------+-------+---------------+------------------+---------+------+------+----------+-------------+
| id | select_type | table     | type  | possible_keys | key              | key_len | ref  | rows | filtered | Extra       |
+----+-------------+-----------+-------+---------------+------------------+---------+------+------+----------+-------------+
| 1  | PRIMARY     | t_student | ALL   | NULL          | NULL             | NULL    | NULL | 1    | 100.00   | Using where |
| 2  | SUBQUERY    | t_classes | index | NULL          | idx_classes_name | 767     | NULL | 20   | 100.00   | Using index |
+----+-------------+-----------+-------+---------------+------------------+---------+------+------+----------+-------------+
```

**type**:表示MySQL在**表中找到所需行的方式，或者叫访问类型。**常见访问类型如下，从上到下，性能由差到最好：

| **ALL**          | 全表扫描                 |
| ---------------- | ------------------------ |
| **index**        | **索引全扫描**           |
| **range**        | **索引范围扫描**         |
| **ref**          | **非唯一索引扫描**       |
| **eq_ref**       | **唯一索引扫描**         |
| **const,system** | **单表最多有一个匹配行** |
| **NULL**         | **不用扫描表或索引**     |

range：如果使用索引获取某些范围区间的记录，那么就可能使用到range访问方法

**possible_keys**: 表示查询可能使用的索引

**key**: 实际使用的索引

**key_len**: 使用索引字段的长度

**ref**: 使用哪个列或常数与key一起从表中选择行。

rows： 也是一个重要的字段. MySQL 查询优化器根据统计信息, 估算 SQL 要查找到结果集需要扫描读取的数据行数.
**这个值非常直观显示 SQL 的效率好坏, 原则上 rows 越少越好.**

## 3. 三大范式

◆ 第一范式（1NF）：强调的是**列的原子性，即列不能够再分成其他几列。**简而言之，第一范式就是无重复的列。
◆ 第二范式（2NF）：首先要满足它是1NF，另外还需要包含两部分内容：一是表必须有一个主键；二是没有包含在主键中的列必须完全依赖于主键，而不能只依赖于主键的一部分。简而言之，第二范式就是**非主属性非部分依赖于主关键字。**

◆ 第三范式（3NF）：首先是 2NF，**另外非主键列必须直接依赖于主键，不能存在传递依赖。**即不能存在：非主键列 A 依赖于非主键列 B，非主键列 B 依赖于主键的情况。简而言之，第三范式（3NF）要求一个数据库表中不包含已在其它表中已包含的非主关键字信息。例如，存在一个部门信息表，其中每个部门有部门编号（dept_id）、部门名称、部门简介等信息。
原文链接：https://blog.csdn.net/traceofsun/article/details/6411344

**范式的存在有什么好处？** 
范式可以**避免数据冗余，减少数据库的空间，减轻维护数据完整性的麻烦**。

## 4. innodb数据存储

innodb存储引擎中，每行数据都包含了一些隐藏字段：DB_ROW_ID、DB_TRX_ID、DB_ROLL_PTR和DELETE_BIT。

DB_TRX_ID：用来标识最近一次对本行记录做修改的事务的标识符，即最后一次修改本行记录的事务id。delete操作在内部来看是一次update操作，更新行中的删除标识位DELELE_BIT。

DB_ROLL_PTR：指向当前数据的**undo log**记录，回滚数据通过这个指针来寻找记录被更新之前的内容信息。

DB_ROW_ID：包含一个随着新行插入而单调递增的行ID, 当由innodb自动产生聚集索引时，聚集索引会包括这个行ID的值，否则这个行ID不会出现在任何索引中。

DELELE_BIT：用于标识该记录是否被删除。数据操作

- insert

  创建一条记录，DB_TRX_ID为当前事务ID，DB_ROLL_PTR为NULL。

- delete

  将当前行的DB_TRX_ID设置为当前事务ID，DELELE_BIT设置为1。

- update 复制一行，新行的DB_TRX_ID为当前事务ID，DB_ROLL_PTR指向上个版本的记录，事务提交后DB_ROLL_PTR设置为NULL。

- select

  1、只查找创建早于当前事务ID的记录，确保当前事务读取到的行都是事务之前就已经存在的，或者是由当前事务创建或修改的；

  2、行的DELETE BIT为1时，查找删除晚于当前事务ID的记录，确保当前事务开始之前，行没有被删除。
  
  作者：梦之痕链接：https://juejin.im/post/5c519bb8f265da617831cfff

# Spring

## 1. 事务机制

