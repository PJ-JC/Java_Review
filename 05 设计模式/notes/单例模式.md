# 1、**单例模式**

　　　　　　保证一个类仅有一个实例，并提供一个访问它的全局访问点。

　　　　　　所有类都有构造方法，不编码则系统默认生成空的构造方法，若有显示定义的构造方法，默认的构造方法就会失效。

　　　　分析：

　　　　　　1、通常我们可以让一个全局变量使得一个对象被访问，但它不能防止你实例化多个对象；

　　　　　　　　一个最好的办法就是，让类自身负责保存它的唯一实例；这个类可以保证没有其他实例可以被创建，并且它可以提供一个访问该实例的方法。

　　　　　　2、单例模式因为Singleton类封装了它的唯一实例，这样它可以严格地控制客户怎样访问它以及何时访问它。简单地说就是对唯一实例的受控访问。

　　　　实用类与单例区别？

　　　　　　　　比如实用类不保存状态，仅提供一些静态方法或静态属性让你使用，而单例类是有状态的；实用类不能用于继承多态，而单例虽然实例唯一，却是可以有子类来继承。

　　　　　　实用类只不过是一些方法属性的集合，而单例却是有着唯一的对象实例。

## 懒汉式单例类：可以延迟加载，多线程不安全

```java
public class Singleton{
    private static Singleton instance;
    private Singleton();
    
    public static Singleton getInstance(){
        if(instance == null){
            instance = new Singleton;
        }
        return instance;
    }
}
```

## 饿汉式单例类：线程安全，加载类时就初始化完成不能延迟加载

```java
public class Singleton{
    private static Singleton instance = new Singleton();
    private Singleton();
    
    public static Singleton getInstance(){
        return instance;
    }

}
```

## 双重检查锁：多线程安全、延迟加载，同步耗时

```java
public class Singleton{
    private volatile static Singleton instance;
    private Singleton();
    
    public static Singleton getInstance(){
        if(instance == null){
            synchronized(Singleton.class);
            if(instance == null){
                instance = new Singleton;
            }
        }
    }
    return instance;
}
```

## 静态内部类：多线程安全，延迟加载，比（双重检查）少耗时

```java
public class Singleton{
    
    private Singleton(){
        
        public static Singleton getInstance(){
        return SingletonHolder.instance;
    }

    private static class SingletonHolder {
        private static Singleton instance = new Singleton();
    }
}
```

