# 两数之和 

## 题目

给定一个整数数组和一个目标值，找出数组中和为目标值的两个数。 
你可以假设每个输入只对应一种答案，且同样的元素不能被重复利用。 

## 示例

给定 nums = [2, 7, 11, 15], target = 9 
因为 nums[0] + nums[1] = 2 + 7 = 9 
所以返回 [0, 1] 

## 思路

可以**借助HashMap，将nums加入到HashMap表中**，其中nums中的数作为key，索引作为value, 判断Hashmap中存在target-x且这个数的索引值不等于x自身即可。

## 代码

```java
public int[] twoSum(int[] nums, int target) {
    Map<Integer, Integer> map = new HashMap<>();
    for (int i = 0; i < nums.length; i++) {
        map.put(nums[i], i);
    }
    for (int i = 0; i < nums.length; i++) {
        int complement = target - nums[i];
        //存在这个数，且这个数的索引和i不同
        if (map.containsKey(complement) && map.get(complement) != i) {
            return new int[] { i, map.get(complement) };
        }
    }
    throw new IllegalArgumentException("No two sum solution");
}
```

# 三数之和

## 题目 

给定一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？找出所有满足条件且不重复的三元组。 
注意：答案中不可以包含重复的三元组。 
例如, 给定数组 nums = [-1, 0, 1, 2, -1, -4]， 
满足要求的三元组集合为： 
[ 
[-1, 0, 1], 
[-1, -1, 2] 
] 

## 思路

跟两数之和不同的是，三数之后要输出的是**不同三元组的集合。**因此，我们考虑**先将nums进行排序，将nums[i]作为第一个加数，从i+1到nums.length-1之间初始化两个指针left，right，为了避免有重复的情况，当nums[i]==nums[i-1],说明有重复的情况，开始下一个循环**。如果num[i]+num[left]+num[right]>0,说明加多了，让right–，如果num[i]+num[left]+num[right]<0,说明加少了，让left++，如果等于0，说明符合条件，将这一组解加到集合中，这是也应该避免第二个加数和第三个加数重复的情况。 

代码
--------------------- 
```java
public static List<List<Integer>> threeSum(int[] nums) {
        List<List<Integer>> list = new ArrayList<List<Integer>>();
        Arrays.sort(nums);
        for (int i = 0; i < nums.length - 1; i++) {
            if (i > 0 && nums[i] == nums[i - 1]) {
                continue;
            }
            int left = i + 1;
            int right = nums.length - 1;
            while (left < right) {
                if (nums[left] + nums[right] + nums[i] > 0) {
                    right--;
                } else if (nums[left] + nums[right] + nums[i] < 0) {
                    left++;
                } else {
                    //满足条件就加入到列表中
                    list.add(Arrays.asList(nums[left], nums[right], nums[i]));
                    left++;
                    right--;
                    while (left < right && nums[left] == nums[left - 1]) {
                        left++;
                    }
                    while (left < right && nums[right] == nums[right + 1]) {
                        right--;
                    }
                }
            }
        }
        return list;
    }
```

# 手写LRU

https://blog.csdn.net/luoweifu/article/details/8297084

# 层次遍历二叉树

题目来源于 LeetCode 第 102 号问题：二叉树的层序遍历。

## 题目

给定一个二叉树，返回其按层次遍历的节点值。 （即逐层地，从左到右访问所有节点）。

例如: 给定二叉树: `[3,9,20,null,null,15,7]`,

```

    3
   / \
  9  20
    /  \
   15   7
```

## 题目解析

该问题需要用到队列。

- 建立一个queue
- 先把根节点放进去，这时候找根节点的左右两个子节点
- 去掉根节点，此时queue里的元素就是下一层的所有节点
- 用for循环遍历，将结果存到一个一维向量里
- 遍历完之后再把这个一维向量存到二维向量里
- 以此类推，可以完成层序遍历

## 代码

```java
public List<List<Integer>> levelOrder(TreeNode root) {
    if(root == null)
        return new ArrayList<>();
    List<List<Integer>> res = new ArrayList<>();
    Queue<TreeNode> queue = new LinkedList<TreeNode>();
    queue.add(root);
    while(!queue.isEmpty()){
        int count = queue.size();
        List<Integer> list = new ArrayList<Integer>();
        while(count > 0){
            TreeNode node = queue.poll();
            list.add(node.val);
            if(node.left != null)
                queue.add(node.left);
            if(node.right != null)
                queue.add(node.right);
            count--;
        }
        res.add(list);
    }
    return res;
}
```

